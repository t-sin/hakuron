@article{Magnusson2009,
abstract = {This paper explores the differences in the design and performance of acoustic and new digital musical instruments, arguing that with the latter there is an increased encapsulation of musical theory. The point of departure is the phenomenology of musical instruments, which leads to the exploration of designed artefacts as extensions of human cognition - as scaffolding onto which we delegate parts of our cognitive processes. The paper succinctly emphasises the pronounced epistemic dimension of digital instruments when compared to acoustic instruments. Through the analysis of material epistemologies it is possible to describe the digital instrument as an epistemic tool: a designed tool with such a high degree of symbolic pertinence that it becomes a system of knowledge and thinking in its own terms. In conclusion, the paper rounds up the phenomenological and epistemological arguments, and points at issues in the design of digital musical instruments that are germane due to their strong aesthetic implications for musical culture. {\textcopyright} 2009 Cambridge University Press.},
author = {Magnusson, Thor},
doi = {10.1017/S1355771809000272},
file = {:Users/tomoya/Downloads/magnusson.pdf:pdf},
issn = {13557718},
journal = {Organised Sound},
month = {8},
number = {2},
pages = {168--176},
title = {{Of epistemic tools: Musical instruments as cognitive extensions}},
volume = {14},
year = {2009}
}
@article{Lazzarini2013,
abstract = {This article traces the history and evolution of Music Programming , from the early off-line synthesis programs of the MUSIC N family to modern realtime interactive systems. It explores the main design characteristics of these systems and their impact on Computer Music. In chronological fashion, the article will examine, with code examples, the development of the early systems into the most common modern languages currently in use. In particular, we will focus on Csound, highlighting its main internal aspects and its applications. The text will also explore the various paradigms that have oriented the design and use of music programming systems. This discussion is completed by a consideration of computer music ecosystems and their pervasiveness in today's practice.},
author = {Lazzarini, Victor},
doi = {10.1080/09298215.2013.778890},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Lazzarini - 2013 - The Development of Computer Music Programming Systems.pdf:pdf},
issn = {1744-5027},
journal = {Journal of New Music Research},
number = {1},
pages = {97--110},
publisher = {Victor Lazzarini},
title = {{The Development of Computer Music Programming Systems}},
url = {https://www.tandfonline.com/action/journalInformation?journalCode=nnmr20},
volume = {42},
year = {2013}
}
@article{Dannenberg2018,
author = {Dannenberg, Roger B.},
doi = {10.3389/fdigh.2018.00026},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Dannenberg - 2018 - Languages for Computer Music.pdf:pdf},
issn = {2297-2668},
journal = {Frontiers in Digital Humanities},
month = {nov},
title = {{Languages for Computer Music}},
url = {https://www.frontiersin.org/article/10.3389/fdigh.2018.00026/full},
volume = {5},
year = {2018}
}
@article{Wang2015,
abstract = {ChucK is a programming language designed for computer music. It aims to be expressive and straightforward to read and write with respect to time and concurrency, and to provide a platform for precise audio synthesis and analysis and for rapid experimentation in computer music. In particular, ChucK defines the notion of a strongly timed audio programming language, comprising a versatile time-based programming model that allows programmers to flexibly and precisely control the flow of time in code and use the keyword now as a time-aware control construct, and gives programmers the ability to use the timing mechanism to realize sample-accurate concurrent programming. Several case studies are presented that illustrate the workings, properties, and personality of the language. We also discuss applications of ChucK in laptop orchestras, computer music pedagogy, and mobile music instruments. Properties and affordances of the language and its future directions are outlined.},
author = {Wang, Ge and Cook, Perry R and Salazar, Spencer},
doi = {10.1162/COMJ_a_00324},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Wang, Cook, Salazar - 2015 - ChucK A Strongly Timed Computer Music Language.pdf:pdf},
journal = {Computer Music Journal},
number = {4},
pages = {10--29},
title = {{ChucK: A Strongly Timed Computer Music Language}},
volume = {39},
year = {2015},
url = {https://ccrma.stanford.edu/~ge/publish/files/2015-cmj-chuck.pdf}
}
@inproceedings{Salazar2012,
author = {Salazar, Spencer and Wang, Ge},
booktitle = {International Computer Music Conference Proceedings},
pages = {60--63},
title = {{CHUGENS, CHUBGRAPHS, CHUGINS: 3 TIERS FOR EXTENDING CHUCK}},
url = {http://hdl.handle.net/2027/spo.bbp2372.2012.010},
year = {2012}
}
@inproceedings{Puckette1997,
author = {Puckette, Miller S.},
booktitle = {International Computer Music Conference Proceedings},
file = {:Users/tomoya/Downloads/puredata_icmc97.pdf:pdf},
issn = {2223-3881},
publisher = {Michigan Publishing, University of Michigan Library},
title = {{Pure Data}},
url = {http://hdl.handle.net/2027/spo.bbp2372.1997.060},
year = {1997}
}

@phdthesis{Sorensen2018,
author = {Sorensen, Andrew Carl},
doi = {10.25911/5D67B75C3AAF0},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Sorensen - 2018 - Extempore The design, implementation and application of a cyber-physical programming language(3).pdf:pdf},
keywords = {Computer Music,Cyber,Extempore,High Performance Computing,Human Computer Interaction,Live Coding,Live Programming,Physical Programming},
school = {The Australian National University},
title = {{Extempore: The design, implementation and application of a cyber-physical programming language}},
year = {2018}
}

@article{Norilo2015,
abstract = {Kronos is a signal-processing programming language based on the principles of semifunctional reactive systems. It is aimed at efficient signal processing at the elementary level, and built to scale towards higher-level tasks by utilizing the powerful programming paradigms of "metaprogramming" and reactive multirate systems. The Kronos language features expressive source code as well as a streamlined, efficient runtime. The programming model presented is adaptable for both sample-stream and event processing, offering a cleanly functional programming paradigm for a wide range of musical signal-processing problems, exemplified herein by a selection and discussion of code examples.},
author = {Norilo, Vesa},
doi = {10.1162/COMJ_a_00330},
journal = {Computer Music Journal},
number = {4},
pages = {30--48},
title = {{Kronos: A Declarative Metaprogramming Language for Digital Signal Processing}},
volume = {39},
year = {2015},
url = {https://dl.acm.org/doi/abs/10.1162/COMJ_a_00330}
}

@inproceedings{Norilo2016,
author = {Norilo, Vesa},
booktitle = {Proceedings of the International Computer Music Conference},
file = {:Users/tomoya/Downloads/kronos-metasequencer.pdf:pdf},
pages = {117--122},
title = {{Kronos Meta-Sequencer â€“ From Ugens to Orchestra, Score and Beyond}},
year = {2016}
}
@phdthesis{Norilo2016phd,
author = {Norilo, Vesa},
file = {:Users/tomoya/Downloads/sisus_b51.pdf:pdf},
school = {University of the Arts Helsinki},
title = {{Kronos: Reimagining musical signal processing}},
year = {2016}
}


@article{Spinellis2001,
abstract = {The realisation of domain-specific languages (DSLS) differs in fundamental ways from that of traditional programming languages. We describe eight recurring patterns that we have identified as being used for DSL design and implementation. Existing languages can be extended, restricted, partially used, or become hosts for DSLS. Simple DSLS can be implemented by lexical processing. In addition, DSLS can be used to create front-ends to existing systems or to express complicated data structures. Finally, DSLS can be combined using process pipelines. The patterns described form a pattern language that can be used as a building block for a systematic view of the software development process involving DSLS. {\textcopyright} 2001 Elsevier Science Inc. All rights reserved.},
author = {Spinellis, Diomidis},
doi = {10.1016/S0164-1212(00)00089-3},
file = {:Users/tomoya/Downloads/dslpat.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Design patterns,Domain-specific languages},
month = {feb},
number = {1},
pages = {91--99},
publisher = {Elsevier Inc.},
title = {{Notable design patterns for domain-specific languages}},
volume = {56},
year = {2001}
}
@article{McCartney2002,
author = {McCartney, James},
doi = {10.1162/014892602320991383},
file = {:Users/tomoya/Downloads/014892602320991383.pdf:pdf},
issn = {01489267},
journal = {Computer Music Journal},
month = {dec},
number = {4},
pages = {61--68},
publisher = {{MIT Press 238 Main St., Suite 500, Cambridge, MA 02142-1046 USA journals-info@mit.edu}},
title = {{Rethinking the computer music language: SuperCollider}},
volume = {26},
year = {2002}
}
@article{Aaron2013,
abstract = {Domain Specific and Functional languages provide an excellent linguistic context for exploring new forms of music notation - not just for formalising compositions but also for live interaction workflows. This experience report describes two novel live coding systems that employ code execution to modify live sounds and music. The first of these systems, Sonic Pi, aims at teaching core computing notions to school students using live-coded music as a means of stimulating and maintaining student engagement. We describe how an emphasis on a functional style improves the ease in which core computer science concepts can be communicated to students. Secondly we describe Overtone, a functional language and live coding environment aimed towards professional electronic musicians. We describe how Overtone's abstractions and architecture strongly benefit from a functional-oriented implementation. Both Sonic Pi and Overtone are freely available open-source platforms.},
author = {Aaron, Samuel and Blackwell, Alan F.},
doi = {10.1145/2505341.2505346},
file = {:Users/tomoya/Downloads/2505341.2505346.pdf:pdf},
isbn = {9781450323864},
journal = {Proceedings of the ACM SIGPLAN International Conference on Functional Programming, ICFP},
keywords = {Computational thinking,Live coding,Pedagogy,Raspberry Pi,Sound synthesis},
pages = {35--46},
title = {{From Sonic Pi to overtone: Creative musical experiences with domain-specific and functional languages}},
year = {2013}
}
@inproceedings{Sorensen2010,
abstract = {The act of computer programming is generally considered to be temporally removed from a computer program's execution. In this paper we discuss the idea of programming as an activity that takes place within the temporal bounds of a real-time computational process and its interactions with the physical world. We ground these ideas within the context of livecoding-a live audiovisual performance practice. We then describe how the development of the programming environment "Impromptu" has addressed our ideas of programming with time and the notion of the programmer as an agent in a cyber-physical system.},
address = {New York, New York, USA},
author = {Sorensen, Andrew and Gardner, Henry},
booktitle = {Proceedings of the ACM international conference on Object oriented programming systems languages and applications - OOPSLA '10},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Sorensen, Gardner - 2010 - Programming With Time Cyber-physical programming with Impromptu(2).pdf:pdf},
isbn = {9781450302036},
keywords = {Concurrency,Cyber-physical Systems,D10 [Programming Techniques]: General-With-Time Programming General Terms Design,Experimentation,Hu-man Factors Keywords Time,Impromptu,Languages,Livecoding},
publisher = {ACM Press},
title = {{Programming With Time Cyber-physical programming with Impromptu}},
year = {2010}
}


@misc{Storer2019,
author = {Storer, Julian},
month = {nov},
title = {{SOUL\_Overview.md}},
url = {https://github.com/soul-lang/SOUL/blob/master/docs/SOUL_Overview.md},
urldate = {2020-03-28},
year = {2019}
}
@misc{Ruiz2020,
author = {Ruiz, Leonardo Laguna},
title = {{Vult Language}},
url = {http://modlfo.github.io/vult/},
urldate = {2020-09-27},
year = {2020}
}


@InProceedings{Lattner2004,
author = {Lattner, Chris and Adve, Vikram},
title = {{LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation}},
year = {2004},
isbn = {0769521029},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
booktitle = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
pages = {75},
location = {Palo Alto, California},
series = {CGO '04},
url = {https://llvm.org/pubs/2004-01-30-CGO-LLVM.html}
}



@article{Orlarey2004,
author = {Orlarey, Y. and Fober, D. and Letz, S.},
doi = {10.1007/s00500-004-0388-1},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Orlarey, Fober, Letz - 2004 - Syntactical and semantical aspects of Faust.pdf:pdf},
isbn = {0050000403},
issn = {14327643},
journal = {Soft Computing},
keywords = {Compiler,Dataflow,Functional programming,Real-time,Signal processing},
number = {9},
pages = {623--632},
title = {{Syntactical and semantical aspects of Faust}},
volume = {8},
year = {2004}
}
@misc{Microsoft2020,
author = {Microsoft},
title = {{Functions - F\# | Microsoft Docs}},
url = {{https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/#function-composition-and-pipelining}},
urldate = {2020-06-06},
year = {2020}
}

@inproceedings{Scavone2002,
address = {Goteborg, Sweden},
author = {Scavone, Gary P.},
booktitle = {Proceedings of the 2002 International Computer Music Conference},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Scavone - 2002 - RtAudio A Cross-Platform C Class for Realtime Audio InputOutput.pdf:pdf},
title = {{RtAudio: A Cross-Platform C++ Class for Realtime Audio Input/Output}},
year = {2002}
}

@misc{Klabnik2020,
author = {{Klabnik, Steve and Nichols}, Carol},
title = {{The Rust Programming Language}},
url = {https://doc.rust-lang.org/book/},
urldate = {2020-06-01},
year = {2020}
}

@inproceedings{Sumii2005,
abstract = {We present a simple compiler, consisting of only 2000 lines of ML, for a strict, impure, monomorphic, and higher-order functional language. Although this language is minimal, our compiler generates as fast code as standard compilers like Objective Caml and GCC for several applications including ray tracing, written in the optimal style of each language implementation. Our primary purpose is education at undergraduate level to convince students-as well as average programmers - that functional languages are simple and efficient. Copyright {\textcopyright} 2005 ACM.},
address = {New York, New York, USA},
author = {Sumii, Eijiro},
booktitle = {FDPE'05 - Proceedings of the ACM SIGPLAN 2005 Workshop on Functional and Declarative Programming in Education},
doi = {10.1145/1085114.1085122},
isbn = {1595930671},
keywords = {Education,ML,Objective Caml,Teaching},
pages = {27--38},
publisher = {ACM Press},
title = {{MinCaml: A simple and efficient compiler for a minimal functional language}},
url = {http://portal.acm.org/citation.cfm?doid=1085114.1085122},
year = {2005}
}

@inproceedings{Dannenberg2005,
abstract = {This document contains a set of "design patterns" for real time systems, particularly for computer music systems. We see these patterns often because the problems that they solve come up again and again. Hopefully, these patterns will serve a more than just a set of canned solutions. It is perhaps even more important to understand the underlying problems, which often have subtle aspects and ramifications. By describing these patterns, we have tried to capture the problems, solutions, and a way of thinking about real-time systems design. We welcome your comments and questions.},
author = {Dannenberg, Roger B and Bencina, Ross},
booktitle = {ICMC 2005 Workshop on Real Time Systems Concepts for Computer Music},
file = {::},
title = {{Design Patterns for Real-Time Computer Music Systems}},
url = {https://www.researchgate.net/publication/242648768_Design_Patterns_for_Real-Time_Computer_Music_Systems},
year = {2005}
}

@misc{Lopo,
author = {Lopo, Erik de Castro},
title = {libsndfile},
year={1990},
url = {http://www.mega-nerd.com/libsndfile/},
urldate = {2021-05-12}
}

@misc{Sorensen2016,
author = {Sorensen, Andrew Carl},
title = {{Time in Extempore}},
url = {https://extemporelang.github.io/docs/overview/time},
urldate = {2021-06-18},
year = {2016}
}
@inproceedings{Ruggieri1988,
abstract = {The choice of binding time disciplines has major consequences for both the run-time efficiency of programs and the convenience of the language expressing algorithms. Late storage binding time, dynamic allocation, provides the flexibility necessary to implement the complex data structures common in today's object oriented style of programming. In this paper we show that compile-time lifetime analysis can be applied to programs written in languages with static type systems and dynamically allocated objects, to provide earlier storage binding time for objects, while maintaining all the advantages of dynamic allocation.},
author = {Ruggieri, Cristina and Murtagh, Thomas P.},
booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
doi = {10.1145/73560.73585},
file = {::},
isbn = {0897912527},
issn = {07308566},
month = {jan},
pages = {285--293},
publisher = {Association for Computing Machinery},
title = {{Lifetime analysis of dynamically allocated objects}},
volume = {Part F130193},
year = {1988}
}
@article{Taha1997,
abstract = {We introduce MetaML, a statically-typed multi-stage programming language extending Nielson and Nielson's two stage notation to an arbitrary number of stages. MetaML extends previous work by introducing four distinct staging annotations which generalize those published previously [25, 12, 7, 6] We give a static semantics in which type checking is done once and for all before the first stage, and a dynamic semantics which introduces a new concept of cross-stage persistence, which requires that variables available in any stage are also available in all future stages. We illustrate that staging is a manual form of binding time analysis. We explain why, even in the presence of automatic binding time analysis, explicit annotations are useful, especially for programs with more than two stages. A thesis of this paper is that multi-stage languages are useful as programming languages in their own right, and should support features that make it possible for programmers to write staged computations without significantly changing their normal programming style. To illustrate this we provide a simple three stage example, and an extended two-stage example elaborating a number of practical issues.},
author = {Taha, Walid and Sheard, Tim},
doi = {10.1145/258994.259019},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Taha, Sheard - 1997 - Multi-Stage Programming with Explicit Annotations.pdf:pdf},
issn = {03621340},
journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
month = {dec},
number = {12},
pages = {203--214},
publisher = {Association for Computing Machinery (ACM)},
title = {{Multi-Stage Programming with Explicit Annotations}},
url = {https://dl-acm-org.anywhere.lib.kyushu-u.ac.jp/doi/abs/10.1145/258994.259019},
volume = {32},
year = {1997}
}

@article{Ganz2001,
abstract = {With few exceptions, macros have traditionally been viewed as operations on syntax trees or even on plain strings. This view makes macros seem ad hoc, and is at odds with two desirable features of contemporary typed functional languages: static typing and static scoping. At a deeper level, there is a need for a simple, usable semantics for macros. This paper argues that these problems can be addressed by formally viewing macros as multi-stage computations. This view eliminates the need for freshness conditions and tests on variable names, and provides a compositional interpretation that can serve as a basis for designing a sound type system for languages supporting macros, or even for compilation. To illustrate our approach, we develop and present MacroML, an extension of ML that supports inlining, recursive macros, and the definition of new binding constructs. The latter is subtle, and is the most novel addition in a statically typed setting. The semantics of a core subset of MacroML is given by an interpretation into MetaML, a statically-typed multi-stage programming language. It is then easy to show that MacroML is stage- and type-safe: macro expansion does not depend on runtime evaluation, and both stages do not "go wrong". Copyright 2001 ACM.},
author = {Ganz, Steven E. and Sabry, Amr and Taha, Walid},
doi = {10.1145/507669.507646},
issn = {03621340},
journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
month = {oct},
number = {10},
pages = {74--85},
publisher = {Association for Computing Machinery},
title = {{Macros as multi-stage computations: Type-safe, generative, binding macros in MacroML}},
url = {https://dl-acm-org.anywhere.lib.kyushu-u.ac.jp/doi/abs/10.1145/507669.507646},
volume = {36},
year = {2001}
}

@inproceedings{McLean2014,
abstract = {Live coding of music has grown into a vibrant international community of research and practice over the past decade, providing a new research domain where computer science blends with the performing arts. In this paper the domain of live coding is described, with focus on the programming language design challenges involved, and the ways in which a functional approach can meet those challenges. This leads to the introduction of Tidal 0.4, a Domain Specific Language embedded in Haskell. This is a substantial restructuring of Tidal, which now represents musical pattern as functions from time to events, inspired by Functional Reactive Programming. {\textcopyright} 2014 ACM.},
address = {New York, New York, USA},
author = {McLean, Alex},
booktitle = {FARM 2014 - Proceedings of the 2014 ACM SIGPLAN International Workshop on Functional Art, Music, Modelling and Design},
doi = {10.1145/2633638.2633647},
file = {:Users/tomoya/Downloads/2633638.2633647.pdf:pdf},
isbn = {9781450330398},
keywords = {domain specific languages,live coding,music},
pages = {63--70},
publisher = {Association for Computing Machinery},
title = {{Making programming languages to dance to: Live coding with tidal}},
url = {http://dl.acm.org/citation.cfm?doid=2633638.2633647},
year = {2014}
}
@inproceedings{kirkbride2016,
author = {Kirkbride, Ryan},
booktitle = {Proceedings of the International Conference on Live Interfaces},
pages = {194--198},
title = {{FoxDot: Live coding with python and supercollider}},
year = {2016}
}
@article{Magnusson2011,
author = {Magnusson, Thor},
issn = {2223-3881},
journal = {International Computer Music Conference Proceedings},
publisher = {Michigan Publishing, University of Michigan Library},
title = {{The IXI Lang: A SuperCollider Parasite for Live Coding}},
url = {http://hdl.handle.net/2027/spo.bbp2372.2011.101},
volume = {2011},
year = {2011}
}


@article{Puckette2002,
abstract = {Max is a computer environment for realizing live electronic music, named in honor of Max Mathews. The history of the Max paradigm is given, including background and influences; development of the three currently supported computer programs (Max/MSP, jmax, and Pd); design issues; scheduling; and programming. It is now possible to usefully assess what Max (the paradigm) does well, what it does less well, and what can be learned from the experience. The computer should ideally feel in the musician's hands like a musical instrument, needing only to be tuned and then played. Although Max has not completely reached this ideal (nor has any other piece of computer music software), it will hopefully prove to have been a step in a good direction.},
author = {Puckette, Miller},
doi = {10.1162/014892602320991356},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Puckette - 2002 - Max at seventeen.pdf:pdf},
issn = {01489267},
journal = {Computer Music Journal},
number = {4},
pages = {31--43},
pmid = {36920865},
title = {{Max at seventeen}},
volume = {26},
year = {2002}
}
