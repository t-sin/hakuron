@article{Magnusson2009,
abstract = {This paper explores the differences in the design and performance of acoustic and new digital musical instruments, arguing that with the latter there is an increased encapsulation of musical theory. The point of departure is the phenomenology of musical instruments, which leads to the exploration of designed artefacts as extensions of human cognition - as scaffolding onto which we delegate parts of our cognitive processes. The paper succinctly emphasises the pronounced epistemic dimension of digital instruments when compared to acoustic instruments. Through the analysis of material epistemologies it is possible to describe the digital instrument as an epistemic tool: a designed tool with such a high degree of symbolic pertinence that it becomes a system of knowledge and thinking in its own terms. In conclusion, the paper rounds up the phenomenological and epistemological arguments, and points at issues in the design of digital musical instruments that are germane due to their strong aesthetic implications for musical culture. {\textcopyright} 2009 Cambridge University Press.},
author = {Magnusson, Thor},
doi = {10.1017/S1355771809000272},
file = {:Users/tomoya/Downloads/magnusson.pdf:pdf},
issn = {13557718},
journal = {Organised Sound},
month = {8},
number = {2},
pages = {168--176},
title = {{Of epistemic tools: Musical instruments as cognitive extensions}},
volume = {14},
year = {2009}
}
@article{Lazzarini2013,
abstract = {This article traces the history and evolution of Music Programming , from the early off-line synthesis programs of the MUSIC N family to modern realtime interactive systems. It explores the main design characteristics of these systems and their impact on Computer Music. In chronological fashion, the article will examine, with code examples, the development of the early systems into the most common modern languages currently in use. In particular, we will focus on Csound, highlighting its main internal aspects and its applications. The text will also explore the various paradigms that have oriented the design and use of music programming systems. This discussion is completed by a consideration of computer music ecosystems and their pervasiveness in today's practice.},
author = {Lazzarini, Victor},
doi = {10.1080/09298215.2013.778890},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Lazzarini - 2013 - The Development of Computer Music Programming Systems.pdf:pdf},
issn = {1744-5027},
journal = {Journal of New Music Research},
number = {1},
pages = {97--110},
publisher = {Victor Lazzarini},
title = {{The Development of Computer Music Programming Systems}},
url = {https://www.tandfonline.com/action/journalInformation?journalCode=nnmr20},
volume = {42},
year = {2013}
}
@article{Dannenberg2018,
author = {Dannenberg, Roger B.},
doi = {10.3389/fdigh.2018.00026},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Dannenberg - 2018 - Languages for Computer Music.pdf:pdf},
issn = {2297-2668},
journal = {Frontiers in Digital Humanities},
month = {nov},
title = {{Languages for Computer Music}},
url = {https://www.frontiersin.org/article/10.3389/fdigh.2018.00026/full},
volume = {5},
year = {2018}
}
@article{Wang2015,
abstract = {ChucK is a programming language designed for computer music. It aims to be expressive and straightforward to read and write with respect to time and concurrency, and to provide a platform for precise audio synthesis and analysis and for rapid experimentation in computer music. In particular, ChucK defines the notion of a strongly timed audio programming language, comprising a versatile time-based programming model that allows programmers to flexibly and precisely control the flow of time in code and use the keyword now as a time-aware control construct, and gives programmers the ability to use the timing mechanism to realize sample-accurate concurrent programming. Several case studies are presented that illustrate the workings, properties, and personality of the language. We also discuss applications of ChucK in laptop orchestras, computer music pedagogy, and mobile music instruments. Properties and affordances of the language and its future directions are outlined.},
author = {Wang, Ge and Cook, Perry R and Salazar, Spencer},
doi = {10.1162/COMJ_a_00324},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Wang, Cook, Salazar - 2015 - ChucK A Strongly Timed Computer Music Language.pdf:pdf},
journal = {Computer Music Journal},
number = {4},
pages = {10--29},
title = {{ChucK: A Strongly Timed Computer Music Language}},
volume = {39},
year = {2015},
url = {https://ccrma.stanford.edu/~ge/publish/files/2015-cmj-chuck.pdf}
}
@inproceedings{Salazar2012,
author = {Salazar, Spencer and Wang, Ge},
booktitle = {International Computer Music Conference Proceedings},
pages = {60--63},
title = {{CHUGENS, CHUBGRAPHS, CHUGINS: 3 TIERS FOR EXTENDING CHUCK}},
url = {http://hdl.handle.net/2027/spo.bbp2372.2012.010},
year = {2012}
}
@inproceedings{Puckette1997,
author = {Puckette, Miller S.},
booktitle = {International Computer Music Conference Proceedings},
file = {:Users/tomoya/Downloads/puredata_icmc97.pdf:pdf},
issn = {2223-3881},
publisher = {Michigan Publishing, University of Michigan Library},
title = {{Pure Data}},
url = {http://hdl.handle.net/2027/spo.bbp2372.1997.060},
year = {1997}
}

@phdthesis{Sorensen2018,
author = {Sorensen, Andrew Carl},
doi = {10.25911/5D67B75C3AAF0},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Sorensen - 2018 - Extempore The design, implementation and application of a cyber-physical programming language(3).pdf:pdf},
keywords = {Computer Music,Cyber,Extempore,High Performance Computing,Human Computer Interaction,Live Coding,Live Programming,Physical Programming},
school = {The Australian National University},
title = {{Extempore: The design, implementation and application of a cyber-physical programming language}},
year = {2018}
}

@article{Norilo2015,
abstract = {Kronos is a signal-processing programming language based on the principles of semifunctional reactive systems. It is aimed at efficient signal processing at the elementary level, and built to scale towards higher-level tasks by utilizing the powerful programming paradigms of "metaprogramming" and reactive multirate systems. The Kronos language features expressive source code as well as a streamlined, efficient runtime. The programming model presented is adaptable for both sample-stream and event processing, offering a cleanly functional programming paradigm for a wide range of musical signal-processing problems, exemplified herein by a selection and discussion of code examples.},
author = {Norilo, Vesa},
doi = {10.1162/COMJ_a_00330},
journal = {Computer Music Journal},
number = {4},
pages = {30--48},
title = {{Kronos: A Declarative Metaprogramming Language for Digital Signal Processing}},
volume = {39},
year = {2015},
url = {https://dl.acm.org/doi/abs/10.1162/COMJ_a_00330}
}

@inproceedings{Norilo2016,
author = {Norilo, Vesa},
booktitle = {Proceedings of the International Computer Music Conference},
file = {:Users/tomoya/Downloads/kronos-metasequencer.pdf:pdf},
pages = {117--122},
title = {{Kronos Meta-Sequencer – From Ugens to Orchestra, Score and Beyond}},
year = {2016}
}
@phdthesis{Norilo2016phd,
author = {Norilo, Vesa},
file = {:Users/tomoya/Downloads/sisus_b51.pdf:pdf},
school = {University of the Arts Helsinki},
title = {{Kronos: Reimagining musical signal processing}},
year = {2016}
}


@article{Spinellis2001,
abstract = {The realisation of domain-specific languages (DSLS) differs in fundamental ways from that of traditional programming languages. We describe eight recurring patterns that we have identified as being used for DSL design and implementation. Existing languages can be extended, restricted, partially used, or become hosts for DSLS. Simple DSLS can be implemented by lexical processing. In addition, DSLS can be used to create front-ends to existing systems or to express complicated data structures. Finally, DSLS can be combined using process pipelines. The patterns described form a pattern language that can be used as a building block for a systematic view of the software development process involving DSLS. {\textcopyright} 2001 Elsevier Science Inc. All rights reserved.},
author = {Spinellis, Diomidis},
doi = {10.1016/S0164-1212(00)00089-3},
file = {:Users/tomoya/Downloads/dslpat.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Design patterns,Domain-specific languages},
month = {feb},
number = {1},
pages = {91--99},
publisher = {Elsevier Inc.},
title = {{Notable design patterns for domain-specific languages}},
volume = {56},
year = {2001}
}
@article{McCartney2002,
author = {McCartney, James},
doi = {10.1162/014892602320991383},
file = {:Users/tomoya/Downloads/014892602320991383.pdf:pdf},
issn = {01489267},
journal = {Computer Music Journal},
month = {dec},
number = {4},
pages = {61--68},
publisher = {{MIT Press 238 Main St., Suite 500, Cambridge, MA 02142-1046 USA journals-info@mit.edu}},
title = {{Rethinking the computer music language: SuperCollider}},
volume = {26},
year = {2002}
}
@book{Tanaka2017,
title={チップチューンのすべて All About Chiptune: ゲーム機から生まれた新しい音楽},
author={田中,治久(hally)},
publisher={誠文堂新光社},
year={2017},
month={5},
date={11},
edition={単行本},
pages={335},
keywords={デジタル音楽, コンピュータミュージック},
isbn={978-4416616215},
isbn10={441661621X},
url={https://lead.to/amazon/jp/?op=bt&la=ja&key=441661621X},
url-am={https://www.amazon.co.jp/dp/441661621X/},
url-ci={https://ci.nii.ac.jp/books/search?advanced=true&isbn=9784416616215},
url-go={https://books.google.com/books?isbn=9784416616215},
url-wo={https://www.worldcat.org/search?qt=l2a&q=isbn%3A9784416616215},
price={￥2,420},
condition={新品},
timestamp={2021-10-04},
}

@article{Aaron2013,
abstract = {Domain Specific and Functional languages provide an excellent linguistic context for exploring new forms of music notation - not just for formalising compositions but also for live interaction workflows. This experience report describes two novel live coding systems that employ code execution to modify live sounds and music. The first of these systems, Sonic Pi, aims at teaching core computing notions to school students using live-coded music as a means of stimulating and maintaining student engagement. We describe how an emphasis on a functional style improves the ease in which core computer science concepts can be communicated to students. Secondly we describe Overtone, a functional language and live coding environment aimed towards professional electronic musicians. We describe how Overtone's abstractions and architecture strongly benefit from a functional-oriented implementation. Both Sonic Pi and Overtone are freely available open-source platforms.},
author = {Aaron, Samuel and Blackwell, Alan F.},
doi = {10.1145/2505341.2505346},
file = {:Users/tomoya/Downloads/2505341.2505346.pdf:pdf},
isbn = {9781450323864},
journal = {Proceedings of the ACM SIGPLAN International Conference on Functional Programming, ICFP},
keywords = {Computational thinking,Live coding,Pedagogy,Raspberry Pi,Sound synthesis},
pages = {35--46},
title = {{From Sonic Pi to overtone: Creative musical experiences with domain-specific and functional languages}},
year = {2013}
}
@inproceedings{Sorensen2010,
abstract = {The act of computer programming is generally considered to be temporally removed from a computer program's execution. In this paper we discuss the idea of programming as an activity that takes place within the temporal bounds of a real-time computational process and its interactions with the physical world. We ground these ideas within the context of livecoding-a live audiovisual performance practice. We then describe how the development of the programming environment "Impromptu" has addressed our ideas of programming with time and the notion of the programmer as an agent in a cyber-physical system.},
address = {New York, New York, USA},
author = {Sorensen, Andrew and Gardner, Henry},
booktitle = {Proceedings of the ACM international conference on Object oriented programming systems languages and applications - OOPSLA '10},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Sorensen, Gardner - 2010 - Programming With Time Cyber-physical programming with Impromptu(2).pdf:pdf},
isbn = {9781450302036},
keywords = {Concurrency,Cyber-physical Systems,D10 [Programming Techniques]: General-With-Time Programming General Terms Design,Experimentation,Hu-man Factors Keywords Time,Impromptu,Languages,Livecoding},
publisher = {ACM Press},
title = {{Programming With Time Cyber-physical programming with Impromptu}},
year = {2010}
}


@misc{Storer2019,
author = {Storer, Julian},
month = {nov},
title = {{SOUL\_Overview.md}},
url = {https://github.com/soul-lang/SOUL/blob/master/docs/SOUL_Overview.md},
urldate = {2020-03-28},
year = {2019}
}
@misc{Ruiz2020,
author = {Ruiz, Leonardo Laguna},
title = {{Vult Language}},
url = {http://modlfo.github.io/vult/},
urldate = {2020-09-27},
year = {2020}
}


@InProceedings{Lattner2004,
author = {Lattner, Chris and Adve, Vikram},
title = {{LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation}},
year = {2004},
isbn = {0769521029},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
booktitle = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
pages = {75},
location = {Palo Alto, California},
series = {CGO '04},
url = {https://llvm.org/pubs/2004-01-30-CGO-LLVM.html}
}

@article{Roads1980,
author = {Mathews, Max and Roads, Curtis},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Mathews, Roads - 1980 - Interview with Max Mathews.pdf:pdf},
journal = {Computer Music Journal},
number = {4},
pages = {15--22},
publisher = {Winter},
title = {{Interview with Max Mathews}},
volume = {4},
year = {1980}
}
@book{Roads2001,
abstract = {原タイトル: The computer music tutorial. 本体価格: 12800円 文献あり},
author = {Roads, Curtis},
edition = {単行本},
isbn = {9784501532109},
keywords = {楽譜・スコア・音楽書},
month = {jan},
pages = {1054},
publisher = {東京電機大学出版局},
title = {コンピュータ音楽: 歴史・テクノロジー・アート},
translator = {青柳,竜也 and 小阪,直敏 and 平田, 圭二 and 堀内,靖雄 and 後藤, 真孝and 引地, 孝文 and 平野 , 砂峰旅 and 松島, 俊明},
url = {https://lead.to/amazon/jp/ex-mendeley-jp.html?key=4501532106},
year = {2001}
}

@article{Nyquist1928,
author = {Nyquist, H.},
doi = {10.1109/T-AIEE.1928.5055024},
issn = {0096-3860},
journal = {Transactions of the American Institute of Electrical Engineers},
month = {apr},
number = {2},
pages = {617--644},
title = {{Certain Topics in Telegraph Transmission Theory}},
url = {http://ieeexplore.ieee.org/document/5055024/},
volume = {47},
year = {1928}
}

@incollection{Nishino2016,
abstract = {INTRODUCCI{\'{O}}N 1 Estamos en un momento de pleno apogeo en lo que se refiere al uso de nuevas metodolog{\'{i}}as en la ense{\~{n}}anza del espa{\~{n}}ol como lengua extranjera, a la implementaci{\'{o}}n de las tecnolog{\'{i}}as de la informaci{\'{o}}n y la comunicaci{\'{o}}n, y a la inclusi{\'{o}}n de elementos l{\'{u}}dicos para mejorar la experiencia de ense{\~{n}}anza y aprendizaje. En este art{\'{i}}culo queremos realizar una aproximaci{\'{o}}n al concepto de gamificaci{\'{o}}n o ludificaci{\'{o}}n, un t{\'{e}}rmino ya presente en el {\'{a}}mbito empresarial y que recientemente se ha adaptado al contexto docente de lenguas extranjeras por las m{\'{u}}ltiples ventajas que pue-de ofrecer durante el aprendizaje. El uso del juego o sus elementos en el contexto de ense{\~{n}}anza y aprendizaje de len-guas extranjeras tiene como fin modificar el comportamiento de los aprendientes hacia el proceso de aprendizaje de la lengua meta; por ejemplo, conseguir que aumente su mo-tivaci{\'{o}}n y que el aprendizaje sea significativo y duradero. No obstante, para conseguir este objetivo es necesario analizar previamente las caracter{\'{i}}sticas contextuales, atender a los objetivos curriculares y ante todo, tener en cuenta las necesidades espec{\'{i}}ficas de los aprendientes. Este art{\'{i}}culo tiene el objetivo principal de promover una reflexi{\'{o}}n sobre este t{\'{e}}rmi-no y su implementaci{\'{o}}n en el aula, as{\'{i}} como proponer una serie de ideas para imple-mentarlas en el contexto del aula. Por {\'{u}}ltimo, queremos despertar en otros profesores de lengua extranjera el inter{\'{e}}s y la curiosidad por implementar la gamificaci{\'{o}}n en sus pr{\'{a}}cticas docentes. 1 Los datos presentados en este taller son una adaptaci{\'{o}}n del taller titulado " Y t{\'{u}}, ¿gamificas? " impartido por Mat{\'{i}}as Hidalgo Gallardo y Antonia Garc{\'{i}}a Jim{\'{e}}nez durante las III Jornadas de formaci{\'{o}}n de profesores de ELE en Hong Kong (13-14 de marzo de 2015). 74 ¿QU{\'{E}} ES LA GAMIFICACI{\'{O}}N? La conceptualizaci{\'{o}}n de este t{\'{e}}rmino tiene su origen en el mundo de los negocios, pues es en este contexto donde se empez{\'{o}} a utilizar. As{\'{i}}, Werbach y Hunter (2012) se-{\~{n}}alan que la gamificaci{\'{o}}n consiste en el uso de elementos de juegos y t{\'{e}}cnicas de dise{\~{n}}o de juegos en contextos no l{\'{u}}dicos. Teniendo en cuenta en el contexto en el que nos encontramos como docentes, la definici{\'{o}}n que acabamos de presentar debe modificarse. Tomaremos como referencia la propuesta de Foncubierta y Rodr{\'{i}}guez (2014) que definen la gamificaci{\'{o}}n como la t{\'{e}}cnica o t{\'{e}}cnicas que el profesor emplea en el dise{\~{n}}o de una actividad, tarea o proceso de aprendizaje (sean de naturaleza anal{\'{o}}gica o digital) introduciendo elementos del juego (insignias, l{\'{i}}-mite de tiempo, puntuaci{\'{o}}n, dados, etc.) y/o su pensamiento (retos, competici{\'{o}}n, etc.) con el fin de enriquecer esa experiencia de aprendizaje, dirigir y/o modificar el comportamiento de los alumnos en el aula (Foncubierta y Rodriguez 2).},
author = {Nishino, Hiroki and Nakatsu, Ryohei},
booktitle = {Handbook of Digital Games and Entertainment Technologies},
doi = {10.1007/978-981-4560-52-8},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Nishino, Nakatsu - 2016 - Computer Music Languages and Systems The Synergy Between Technology and Creativity.pdf:pdf},
isbn = {978-981-4560-52-8},
title = {{Computer Music Languages and Systems: The Synergy Between Technology and Creativity}},
url = {http://link.springer.com/10.1007/978-981-4560-52-8},
year = {2015}
}

@article{Nishino2014,
author = {Nishino, Hiroki and Osaka, Naotoshi and Nakatsu, Ryohei},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Nishino, Osaka, Nakatsu - 2014 - LC A New Computer Music Programming Language with Three Core Features.pdf:pdf},
isbn = {9789604661374},
journal = {International Computer Music Conference},
number = {September},
pages = {14--20},
title = {{LC: A New Computer Music Programming Language with Three Core Features}},
year = {2014}
}


@article{Orlarey2004,
author = {Orlarey, Y. and Fober, D. and Letz, S.},
doi = {10.1007/s00500-004-0388-1},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Orlarey, Fober, Letz - 2004 - Syntactical and semantical aspects of Faust.pdf:pdf},
isbn = {0050000403},
issn = {14327643},
journal = {Soft Computing},
keywords = {Compiler,Dataflow,Functional programming,Real-time,Signal processing},
number = {9},
pages = {623--632},
title = {{Syntactical and semantical aspects of Faust}},
volume = {8},
year = {2004}
}
@misc{Microsoft2020,
author = {Microsoft},
title = {{Functions - F\# | Microsoft Docs}},
url = {{https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/#function-composition-and-pipelining}},
urldate = {2020-06-06},
year = {2020}
}

@inproceedings{Scavone2002,
address = {Goteborg, Sweden},
author = {Scavone, Gary P.},
booktitle = {Proceedings of the 2002 International Computer Music Conference},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Scavone - 2002 - RtAudio A Cross-Platform C Class for Realtime Audio InputOutput.pdf:pdf},
title = {{RtAudio: A Cross-Platform C++ Class for Realtime Audio Input/Output}},
year = {2002}
}

@misc{Klabnik2020,
author = {{Klabnik, Steve and Nichols}, Carol},
title = {{The Rust Programming Language}},
url = {https://doc.rust-lang.org/book/},
urldate = {2020-06-01},
year = {2020}
}

@inproceedings{Sumii2005,
abstract = {We present a simple compiler, consisting of only 2000 lines of ML, for a strict, impure, monomorphic, and higher-order functional language. Although this language is minimal, our compiler generates as fast code as standard compilers like Objective Caml and GCC for several applications including ray tracing, written in the optimal style of each language implementation. Our primary purpose is education at undergraduate level to convince students-as well as average programmers - that functional languages are simple and efficient. Copyright {\textcopyright} 2005 ACM.},
address = {New York, New York, USA},
author = {Sumii, Eijiro},
booktitle = {FDPE'05 - Proceedings of the ACM SIGPLAN 2005 Workshop on Functional and Declarative Programming in Education},
doi = {10.1145/1085114.1085122},
isbn = {1595930671},
keywords = {Education,ML,Objective Caml,Teaching},
pages = {27--38},
publisher = {ACM Press},
title = {{MinCaml: A simple and efficient compiler for a minimal functional language}},
url = {http://portal.acm.org/citation.cfm?doid=1085114.1085122},
year = {2005}
}

@inproceedings{Dannenberg2005,
abstract = {This document contains a set of "design patterns" for real time systems, particularly for computer music systems. We see these patterns often because the problems that they solve come up again and again. Hopefully, these patterns will serve a more than just a set of canned solutions. It is perhaps even more important to understand the underlying problems, which often have subtle aspects and ramifications. By describing these patterns, we have tried to capture the problems, solutions, and a way of thinking about real-time systems design. We welcome your comments and questions.},
author = {Dannenberg, Roger B. and Bencina, Ross},
booktitle = {ICMC 2005 Workshop on Real Time Systems Concepts for Computer Music},
file = {::},
title = {{Design Patterns for Real-Time Computer Music Systems}},
url = {https://www.researchgate.net/publication/242648768_Design_Patterns_for_Real-Time_Computer_Music_Systems},
year = {2005}
}

@misc{Lopo,
author = {Lopo, Erik de Castro},
title = {libsndfile},
year={1990},
url = {http://www.mega-nerd.com/libsndfile/},
urldate = {2021-05-12}
}

@misc{Sorensen2016,
author = {Sorensen, Andrew Carl},
title = {{Time in Extempore}},
url = {https://extemporelang.github.io/docs/overview/time},
urldate = {2021-06-18},
year = {2016}
}
@inproceedings{Ruggieri1988,
abstract = {The choice of binding time disciplines has major consequences for both the run-time efficiency of programs and the convenience of the language expressing algorithms. Late storage binding time, dynamic allocation, provides the flexibility necessary to implement the complex data structures common in today's object oriented style of programming. In this paper we show that compile-time lifetime analysis can be applied to programs written in languages with static type systems and dynamically allocated objects, to provide earlier storage binding time for objects, while maintaining all the advantages of dynamic allocation.},
author = {Ruggieri, Cristina and Murtagh, Thomas P.},
booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
doi = {10.1145/73560.73585},
file = {::},
isbn = {0897912527},
issn = {07308566},
month = {jan},
pages = {285--293},
publisher = {Association for Computing Machinery},
title = {{Lifetime analysis of dynamically allocated objects}},
volume = {Part F130193},
year = {1988}
}
@article{Taha1997,
abstract = {We introduce MetaML, a statically-typed multi-stage programming language extending Nielson and Nielson's two stage notation to an arbitrary number of stages. MetaML extends previous work by introducing four distinct staging annotations which generalize those published previously [25, 12, 7, 6] We give a static semantics in which type checking is done once and for all before the first stage, and a dynamic semantics which introduces a new concept of cross-stage persistence, which requires that variables available in any stage are also available in all future stages. We illustrate that staging is a manual form of binding time analysis. We explain why, even in the presence of automatic binding time analysis, explicit annotations are useful, especially for programs with more than two stages. A thesis of this paper is that multi-stage languages are useful as programming languages in their own right, and should support features that make it possible for programmers to write staged computations without significantly changing their normal programming style. To illustrate this we provide a simple three stage example, and an extended two-stage example elaborating a number of practical issues.},
author = {Taha, Walid and Sheard, Tim},
doi = {10.1145/258994.259019},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Taha, Sheard - 1997 - Multi-Stage Programming with Explicit Annotations.pdf:pdf},
issn = {03621340},
journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
month = {dec},
number = {12},
pages = {203--214},
publisher = {Association for Computing Machinery (ACM)},
title = {{Multi-Stage Programming with Explicit Annotations}},
url = {https://dl-acm-org.anywhere.lib.kyushu-u.ac.jp/doi/abs/10.1145/258994.259019},
volume = {32},
year = {1997}
}
@article{Dannenberg1997,
author = {Dannenberg, Roger B.},
file = {:Users/tomoya/Downloads/3681015.pdf:pdf},
issn = {01489267, 15315169},
journal = {Computer Music Journal},
number = {3},
pages = {71--82},
publisher = {The MIT Press},
title = {{The Implementation of Nyquist, A Sound Synthesis Language}},
url = {http://www.jstor.org/stable/3681015},
volume = {21},
year = {1997}
}

@article{Ganz2001,
abstract = {With few exceptions, macros have traditionally been viewed as operations on syntax trees or even on plain strings. This view makes macros seem ad hoc, and is at odds with two desirable features of contemporary typed functional languages: static typing and static scoping. At a deeper level, there is a need for a simple, usable semantics for macros. This paper argues that these problems can be addressed by formally viewing macros as multi-stage computations. This view eliminates the need for freshness conditions and tests on variable names, and provides a compositional interpretation that can serve as a basis for designing a sound type system for languages supporting macros, or even for compilation. To illustrate our approach, we develop and present MacroML, an extension of ML that supports inlining, recursive macros, and the definition of new binding constructs. The latter is subtle, and is the most novel addition in a statically typed setting. The semantics of a core subset of MacroML is given by an interpretation into MetaML, a statically-typed multi-stage programming language. It is then easy to show that MacroML is stage- and type-safe: macro expansion does not depend on runtime evaluation, and both stages do not "go wrong". Copyright 2001 ACM.},
author = {Ganz, Steven E. and Sabry, Amr and Taha, Walid},
doi = {10.1145/507669.507646},
issn = {03621340},
journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
month = {oct},
number = {10},
pages = {74--85},
publisher = {Association for Computing Machinery},
title = {{Macros as multi-stage computations: Type-safe, generative, binding macros in MacroML}},
url = {https://dl-acm-org.anywhere.lib.kyushu-u.ac.jp/doi/abs/10.1145/507669.507646},
volume = {36},
year = {2001}
}

@inproceedings{McLean2014,
abstract = {Live coding of music has grown into a vibrant international community of research and practice over the past decade, providing a new research domain where computer science blends with the performing arts. In this paper the domain of live coding is described, with focus on the programming language design challenges involved, and the ways in which a functional approach can meet those challenges. This leads to the introduction of Tidal 0.4, a Domain Specific Language embedded in Haskell. This is a substantial restructuring of Tidal, which now represents musical pattern as functions from time to events, inspired by Functional Reactive Programming. {\textcopyright} 2014 ACM.},
address = {New York, New York, USA},
author = {McLean, Alex},
booktitle = {FARM 2014 - Proceedings of the 2014 ACM SIGPLAN International Workshop on Functional Art, Music, Modelling and Design},
doi = {10.1145/2633638.2633647},
file = {:Users/tomoya/Downloads/2633638.2633647.pdf:pdf},
isbn = {9781450330398},
keywords = {domain specific languages,live coding,music},
pages = {63--70},
publisher = {Association for Computing Machinery},
title = {{Making programming languages to dance to: Live coding with tidal}},
url = {http://dl.acm.org/citation.cfm?doid=2633638.2633647},
year = {2014}
}
@inproceedings{kirkbride2016,
author = {Kirkbride, Ryan},
booktitle = {Proceedings of the International Conference on Live Interfaces},
pages = {194--198},
title = {{FoxDot: Live coding with python and supercollider}},
year = {2016}
}
@article{Magnusson2011,
author = {Magnusson, Thor},
issn = {2223-3881},
journal = {International Computer Music Conference Proceedings},
publisher = {Michigan Publishing, University of Michigan Library},
title = {{The IXI Lang: A SuperCollider Parasite for Live Coding}},
url = {http://hdl.handle.net/2027/spo.bbp2372.2011.101},
volume = {2011},
year = {2011}
}


@article{Puckette2002,
abstract = {Max is a computer environment for realizing live electronic music, named in honor of Max Mathews. The history of the Max paradigm is given, including background and influences; development of the three currently supported computer programs (Max/MSP, jmax, and Pd); design issues; scheduling; and programming. It is now possible to usefully assess what Max (the paradigm) does well, what it does less well, and what can be learned from the experience. The computer should ideally feel in the musician's hands like a musical instrument, needing only to be tuned and then played. Although Max has not completely reached this ideal (nor has any other piece of computer music software), it will hopefully prove to have been a step in a good direction.},
author = {Puckette, Miller},
doi = {10.1162/014892602320991356},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Puckette - 2002 - Max at seventeen.pdf:pdf},
issn = {01489267},
journal = {Computer Music Journal},
number = {4},
pages = {31--43},
pmid = {36920865},
title = {{Max at seventeen}},
volume = {26},
year = {2002}
}
@phdthesis{Brandt2002,
author = {Brandt, Eli},
file = {:Users/tomoya/Documents/brandt.pdf:pdf},
pages = {168},
school = {School of Computer Science, Carnegie Mellon University},
title = {{Temporal type constructors for computer music programming}},
type = {PhD Thesis},
year = {2002}
}

@article{Mcpherson2020,
abstract = {It is widely accepted that acoustic and digital musical instruments shape the cognitive processes of the performer on both embodied and conceptual levels, ultimately influencing the structure and aesthetics of the resulting performance. In this article we examine the ways in which computer music languages might similarly influence the aesthetic decisions of the digital music practitioner, even when those languages are designed for generality and theoretically capable of implementing any sound-producing process. We examine the basis for querying the non-neutrality of tools with a particular focus on the concept of idiomaticity: patterns of instruments or languages which are particularly easy or natural to execute in comparison to others. We then present correspondence with the developers of several major music programming languages and a survey of digital musical instrument creators examining the relationship between idiomatic patterns of the language and the characteristics of the resulting instruments and pieces. In an open-ended creative domain, asserting causal relationships is difficult and potentially inappropriate, but we find a complex interplay between language, instrument, piece and performance that suggests that the creator of the music programming language should be considered one party to a creative conversation that occurs each time a new instrument is designed.},
author = {McPherson, Andrew and Tahlroǧlu, Koray},
doi = {10.1017/S1355771819000463},
file = {:Users/tomoya/Downloads/Document_6790458_59753.pdf:pdf},
issn = {14698153},
journal = {Organised Sound},
number = {1},
pages = {53--63},
title = {{Idiomatic Patterns and Aesthetic Influence in Computer Music Languages}},
volume = {25},
year = {2020}
}
@article{Park2009,
author = {{Hong Park}, Tae and Hall, Dixon},
file = {::},
journal = {Computer Music Journal},
number = {3},
pages = {9--22},
title = {{An Interview with Max Mathews}},
url = {http://direct.mit.edu/comj/article-pdf/33/3/9/1855364/comj.2009.33.3.9.pdf},
volume = {33},
year = {2009}
}
@article{Mathews1963,
abstract = {A computer can be programmed to play "instrumental" music, to aid the composer, or to compose unaided. M. V. Mathews With the aid of suitable output equipment , the numbers which a modern digital computer generates can be directly converted to sound waves. The process is completely general, and any perceiv-able sound can be so produced. This potentiality of the computer has been of considerable use at the Bell Telephone Laboratories in generating stimuli for experiments in the field of hearing, and for generating speech sounds and connected speech in investigations of the factors which contribute to the intelligibility and naturalness of speech. The quality of sound is of great importance in two fields-that of speech and communication and that of music. Our studies at the Bell Laboratories in the first of these fields have led us, over the past few years, to related studies in the production of musical sounds and their organization into musical compositions. I believe that this by-product of our work on speech and hearing may be of considerable value in the world of music, and that further work in this direction will be of substantial value in furthering our understanding of psychoacoustics. There are no theoretical limitations to the performance of the computer as a source of musical sounds, in contrast to the performance of ordinary instruments. At present, the range of computer music is limited principally by cost and by our knowledge of psycho-acoustics. These limits are rapidly receding. In addition to generating sound, the computer can also function as a machine for composing music. It can either compose pieces based entirely on random numbers generated by itself or it can cooperate with a human composer. It can play its own compositions. Here I first describe the process for converting numbers to sounds, then I describe a program for playing music. Next I consider a psychoacoustic problem which is typical of those posed in attempts to make more interesting sounds. Finally, I look to the future, to the time when the computer is itself the composer. Sound from Numbers How can the numbers with which a computer deals be converted into sounds the ear can hear? The most general conversion is based upon the use of the numbers as samples of the sound pressure wave. A schematic diagram of this process is shown in Fig. 1. Here a sequence of numbers from the computer is put into an analog-to-digital converter, which generates a se-' quence of electric pulses whose amplitudes are proportional to the numbers. These pulses are smoothed with a filter and then converted to a sound wave by means of an ordinary loudspeaker. Intuitively, we feel that if a high enough pulse rate is used and the amplitudes of the pulses are generated with sufficient precision, then any sound wave can be closely approximated by this process. Mathematically, it has been established (1) that this conclusion is correct. A sound wave with frequencies from 0 to B cycles per second can be generated from a sequence of two B pulses per second. Thus, for example, by running our computer at a rate of 30,000 numbers per second, we can generate sound waves with frequencies from 0 to 15,000 cycles per second. Waves in this frequency range are about the only ones the human ear can perceive. The signal-to-quantizing-noise ratio of the sound wave depends on the accuracy with which the amplitudes of the pulses are represented. Computers deal with a finite number of digits and, hence, have limited accuracy. However, the computer limits are more than sufficient acoustically. For example, amplitudes represented by four-digit decimal numbers, are accurate to within 1 part in 10,000, an accuracy which represents a signal-to-noise ratio of 80 decibels; this is less noise than the ear can hear, and less noise than would be introduced by any audio equipment, such as the best tape recorder. The sampling process just described is theoretically unrestricted, but the generation of sound signals requires very high sampling rates. The question should immediately be asked, "Are computers of the type now available capable of generating numbers at these rates?" The answer is "Yes," with some qualifications. A high-speed machine such as the I.B.M. 7090, using the programs described later in this article, can compute only about 5000 numbers per second When generating a reasonably complex sound. However, the numbers can be temporarily stored on one of the computer's digital magnetic tapes, and this tape can subsequently be replayed at rates up to 30,000 numbers per second (each number being a 12-bit binary number). Thus, the computer is capable of generating wideband musical sounds. Because of the cost of computer time, we often limit our studies to those for which the computer is run at lower rates, such as 10,000 numbers per second a rate which yields a bandwidth of 5000 cycles per second. The direct conversion of numbers to sound is only one of the ways in which the computer can generate sounds. An alternate procedure is to use the numbers from the computer to control electronic apparatus such as oscillators and filters, which, in turn, generate the sounds. These processes have been carried out by the Radio Corporation of America music synthesizer (2) and by a machine constructed at the University of Illinois (3). This procedure has the advantage that a much lower rate 553},
author = {Mathews, M.V.},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Mathews - 1963 - The Digital Computer as a Musical Instrument.pdf:pdf},
journal = {Science,New Series},
month = {nov},
number = {3592},
pages = {553--557},
title = {{The Digital Computer as a Musical Instrument}},
url = {http://www.jstor.org/stable/1712380},
volume = {142},
year = {1963}
}
@article{Puckette2015,
abstract = {The fundamental principle of Computer Music is usually taken to be the Nyquist Theorem, which, in its usually cited form, states that a band-limited function can be exactly represented by sampling it at regular intervals. This paper will not quarrel with the theorem itself, but rather will test the assump-tions under which it is commonly applied, and endeavor to show that there are interesting approaches to computer music that lie outside the framework of the sampling theorem. As we will see in Section 3, sampling violations are ubiquitous in every-day electronic music practice. The severity of these violations can usually be mitigated either through various engineering practices and/or careful critical lis-tening. But their existence gives the lie to the popular understanding of digital audio practice as being " lossless " . This is not to deny the power of modern digital signal processing theory and its applications, but rather to claim that its underlying assumption—that the sampled signals on which we are operating are to be thought of as exactly rep-resenting band-limited continuous-time functions—sheds light on certain digital operations (notably time-invariant filtering) but not so aptly on others, such as classical synthesizer waveform generation. Digital audio practitioners cannot escape the necessity of representing contin-uous-time signals with finite-sized data structures. But the blanket assumption that such signals can only be represented via the sampling theorem can be unnecessarily limiting. In Sections 4 and 6 I'll describe investigations by two recent UCSD graduates that each adopt a distinct approach to audio manipu-lation outside the framework of the sampling theorem. A collection of accompanying patches that demonstrate some of these ideas can be downloaded from msp.ucsd.edu/ideas/icmc15-examples/. 1 1 The assumptions Band-limited functions are a vector space: you can scale one of them, or add two of them, to get another. But that is where closure ends. The trouble begins as soon as we even go so far as to multiply one signal by another. Suppose two sampled signals, X[n] and Y [n], are used to represent two continuous functions of time x(t), y(t), which we assume to be band-limited, containing only frequen-cies in the Nyquist frequency band, the interval (−R/2, R/2) where R is the sample rate. The values can either be real or complex, and for simplicity we'll assume the computer can exactly represent the numerical values. (It isn't true but that is usually a comparatively minor issue). There is, of course, a perfectly good continuous-time signal, call it z(t), that is represented by the computable product, Z[n] = X[n]Y [n]. But it's not in general the case that z(t) = x(t)y(t). We didn't in reality make the product of the two continuous-time signals we were representing when we multiplied their computer representations. At this point we can look ruefully back at every occurrence of the character " * " in all the Csound, Pd, SuperCollider, Kyma, 4X, or MUSIC 10 instruments we've ever built and reflect on the fact that the result isn't really correct, if we regard our sampled signals as representing continuous-time ones. Often it's a very serviceable approximation. If, for instance, the signals x(t) and y(t) have frequency limits whose sum is less than R/2, the multiplication is exact; and when not exact, it is often a very good approximation. But the approximation's accuracy or lack thereof is rarely worked out explicitly. We could always take action to band-limit two signals (by filtering them) before multiplying so that the multiplication itself doesn't yield frequencies out-side the Nyquist frequency band. But this would cause delays and/or phase distortion, not to mention the computational cost this would incur. One fundamental operation in electronic music practice (in my thinking, the most fundamental one) is table lookup, which is used in digital oscillators and samplers, and also in nonlinear techniques such as FM and waveshaping. Again sidestepping the comparatively minor issue of the accuracy limits of wavetable lookup, we instead again consider the possibility of frequency products landing outside the Nyquist band. Suppose the incoming signal is a sinusoid of frequency $\omega$ and that the wavetable lookup can be approximated as a power series, f (x) = a 0 + a 1 x + a 2 x 2 + {\textperiodcentered} {\textperiodcentered} {\textperiodcentered}},
author = {Puckette, Miller},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Puckette - 2015 - The Sampling Theorem and Its Discontents.pdf:pdf},
journal = {International Computer Music Conference},
pages = {1--14},
title = {{The Sampling Theorem and Its Discontents}},
url = {http://msp.ucsd.edu/Publications/icmc15.pdf},
year = {2015}
}
@inproceedings{Coblenz2018,
abstract = {Approaches for programming language design used commonly in the research community today center around theoretical and performance-oriented evaluation. Recently, researchers have been considering more approaches to language design, including the use of quantitative and qualitative user studies that examine how different designs might affect programmers. In this paper, we argue for an interdisci-plinary approach that incorporates many different methods in the creation and evaluation of programming languages. We argue that the addition of user-oriented design techniques can be helpful at many different stages in the programming language design process. CCS Concepts • Software and its engineering → General programming languages; • Social and professional topics → History of programming languages;},
address = {New York, NY, USA},
author = {Coblenz, Michael and Aldrich, Jonathan and Myers, Brad A and Sunshine, Joshua and Sun, Joshua},
booktitle = {Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Coblenz et al. - 2018 - Interdisciplinary Programming Language Design(2).pdf:pdf},
isbn = {9781450360319},
keywords = {programming language design,programming language evaluation,user-centered design},
pages = {14},
publisher = {ACM},
title = {{Interdisciplinary Programming Language Design}},
url = {https://doi.org/10.1145/3276954.},
year = {2018}
}
@inproceedings{Racket,
abstract = {The Racket language promotes a language-oriented style of programming. Developers create many domain-specific languages, write programs in them, and compose these programs via Racket code. This style of programming can work only if creating and composing little languages is simple and effective. While Racket's Lisp heritage might suggest that macros suffice, its design team discovered significant shortcomings and had to improve them in many ways. This paper presents the evolution of Racket's macro system, including a false start, and assesses its current state.},
author = {Culpepper, Ryan and Felleisen, Matthias and Flatt, Matthew and Krishnamurthi, Shriram},
booktitle = {Leibniz International Proceedings in Informatics, LIPIcs},
doi = {10.4230/LIPIcs.SNAPL.2019.5},
isbn = {9783959771139},
issn = {18688969},
keywords = {Design principles,Domain-specific languages,Macros systems},
month = {jul},
publisher = {Schloss Dagstuhl- Leibniz-Zentrum fur Informatik GmbH, Dagstuhl Publishing},
title = {{From macros to DSLs: The evolution of racket}},
volume = {136},
year = {2019}
}


@incollection{Popp2001,
author = {ポップ, マーカス},
booktitle = {ポスト・テクノ(ロジー)ミュージック―拡散する「音楽」、解体する「人間},
chapter = {2−5},
isbn = {4756320260},
pages = {220--243},
publisher = {大村書店},
title = {オヴァルプロセス講義 オヴァル的メソッドとその音楽的アプローチ},
year = {2001}
}

@incollection{Cascone2005,
author = {カスコーン, キム},
booktitle = {ユリイカ 特集＊ポスト・ノイズ 越境するサウンド},
number = {58-69},
title = {失敗の美学 現代のコンピュータ音楽における「ポスト−デジタル」的傾向},
translator = {長壁, 順子},
volume = {37},
year = {2005}
}

@techreport{Manovich1999,
author = {Manovich, Lev},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Manovich - 1999 - New Media a User's Guide.pdf:pdf},
title = {{New Media: a User's Guide}},
url = {http://manovich.net/content/04-projects/026-new-media-a-user-s-guide/23_article_1999.pdf},
year = {1999}
}

@article{Anderson1990,
abstract = {A computer music performance system 1990 is a computer system connected to input devices (including musical keyboards or other instruments) and to graphic and audio output devices. A human performer generates input events using the input devices. The CMPS responds to these events by computing and performing sequences of output actions whose intended timing is determined algorithmically. Because of the need for accurate timing of output actions, the scheduling requirements of a CMPS differ from those of general-purpose or conventional real-time systems. This paper describes the scheduling facilities of FORMULA, a CMPS used by many musicians. In addition to providing accurate timing of output action sequences, FORMULA provides other basic functions useful in musical applications: (1) per-process virtual time systems with independent relationships to real time; (2) process grouping mechanisms and language-level control structures with time-related semantics, and (3) integrated scheduling of tasks (such as compiling and editing) whose real-time constraints are less stringent than those of output action computations. {\textcopyright} 1990, ACM. All rights reserved.},
author = {Anderson, David P. and Kuivila, Ron},
doi = {10.1145/77648.77652},
file = {:Users/tomoya/Downloads/p56-anderson.pdf:pdf},
issn = {15577333},
journal = {ACM Transactions on Computer Systems (TOCS)},
keywords = {Action buffering,Design,Human Factors,Languages,Performance,deadline scheduling,message-passing,process groups,virtual time systems},
number = {1},
pages = {56--82},
title = {{A System for Computer Music Performance}},
volume = {8},
year = {1990}
}

@book{Born1995,
author = {Born, Georgina},
isbn = {0520202163},
number = {1},
publisher = {University of California Press},
title = {{Rationalizing Culture}},
year = {1995}
}
@book{Ma2014,
author = {馬, 定延},
isbn = {978-4865591163},
pages = {368},
publisher = {アルテスパブリッシング},
title = {日本メディアアート史},
year = {2014}
}

@mastersthesis{Matsuura2019mathesis,
author = {松浦, 知也},
school = {九州大学大学院芸術工学府},
title = {メディア考古学的視点から音の生成を再考する3つの作品制作},
year = {2019}
}

@inproceedings{Matsuura2019jssa,
abstract = {本発表では、時間を分割する機能のみを持ったコンピューターとしての回路彫刻作品「Electronic Delay Time Automatic Calculator」について、その詳細を述べる。本作品は電気パルスの遅延フィードバックという、マスタークロックを持たない異なる時間構造の表現を、メディア考古学的視点より考察するものである。コンピューターを用いた音生成の黎明期に存在した、CSIRACやFerranti Mark Ⅰという、PCM形式によらずに音をデジタル的に直接生成する先例を足がかりに、ソフトウェアとハードウェアの不可分性および、時間の定量的な記述に着目し、今日計算機を用いて音を生成することの意味を再考する。},
author = {松浦, 知也 and 城, 一裕},
booktitle = {先端芸術音楽創作学会 会報},
month = {mar},
pages = {43--49},
publisher = {先端芸術音楽創作学会},
title = {{計算機による音生成の異なるあり方を探る『Electronic Delay Time Automatic Calculator』の制作}},
url = {http://data.jssa.info/paper/2019v11n01/9.Matsuura.pdf},
year = {2019}
}

@article{Matsuura2019MUS,
  title={音楽プログラミング言語のソースコードを楽譜と捉え, それを編集するツールの構想},
  author={松浦知也 and 城一裕 and others},
  journal={研究報告音楽情報科学 (MUS)},
  volume={2019},
  number={17},
  pages={1--4},
  year={2019}
}

@article{Mayer2018,
author = {Mayer, Mika{\"{e}}l and Kuncak, Viktor and Chugh, Ravi},
doi = {10.1145/3276497},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Mayer, Kuncak, Chugh - 2018 - Bidirectional evaluation with direct manipulation.pdf:pdf},
issn = {24751421},
journal = {Proceedings of the ACM on Programming Languages},
keywords = {Bidirectional Programming,Direct Manipulation,Sketch-n-Sketch},
month = {oct},
number = {OOPSLA},
pages = {1--28},
publisher = {ACM},
title = {{Bidirectional evaluation with direct manipulation}},
url = {http://dl.acm.org/citation.cfm?doid=3288538.3276497},
volume = {2},
year = {2018}
}

@article{Jacobs2017,
abstract = {Figure 1. Left: Para's interface. Right: Para enables artists to quickly set up constraints using direct manipulation interactions with their art. Here, an artist has set up a series of color constraints that makes exploring color variations highly efficient. ABSTRACT Computation is a powerful artistic medium. Artists with experience in programming have demonstrated the unique creative opportunities of using code to make art. Currently, manual artists interested in using procedural techniques must undergo the difficult process of learning to program, and must adopt tools and practices far removed from those to which they are accustomed. We hypothesize that, through the right direct manipulation interface, we can enable accessible and expressive procedural art creation. To explore this, we developed Para, a digital illustration tool that supports the creation of declarative constraints in vector artwork. Para's constraints enable procedural relationships while facilitating live manual control and non-linear editing. Constraints can be combined with duplication behaviors and ordered collections of artwork to produce complex, dynamic compositions. We use the results of two open-ended studies with professional artists and designers to provide guidelines for accessible tools that integrate manual and procedural expression.},
author = {Jacobs, Jennifer and Gogia, Sumit and M{\v{e}}ch, Radom{\'{i}}r and Brandt, Joel},
doi = {10.1145/3025453.3025927},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Jacobs et al. - Unknown - Supporting Expressive Procedural Art Creation through Direct Manipulation.pdf:pdf},
isbn = {978-1-4503-4655-9},
keywords = {SIGCHI,archival format,proceedings},
title = {{Supporting Expressive Procedural Art Creation through Direct Manipulation}},
url = {http://github.com/mitmedialab/para.}
}

@phdthesis{Mclean2011,
author = {Mclean, Christopher Alex},
file = {:Users/tomoya/Library/Application Support/Mendeley Desktop/Downloaded/Mclean - 2011 - Artist-Programmers and Programming Languages for the Arts.pdf:pdf},
school = {Goldsmiths, University of London},
title = {{Artist-Programmers and Programming Languages for the Arts}},
url = {https://slab.org/writing/thesis.pdf},
year = {2011}
}
