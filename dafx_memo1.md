1. Capability that can describe both of score-level events and signal processing in one language.
2. providing “natural” functional descriptions of signal flow while at the same time enabling the expression of state changes, discrete events, and their interaction with signals.
3. providing a way to inspect complex internal state of functions.



# claim

楽譜と信号処理両方を扱え、ブラックボックスが少なく、リアルタイム実行できるパフォーマンスがある音楽プログラミング言語を開発することで、音楽をコードとして配布するインフラを整備した。

# abstract

音楽プログラミング言語をデザインにするにあたって、1.楽譜と信号処理を一つの言語体系で表現できること、2. 信号処理の表現におけるブラックボックスを減らすことは近年の課題となっている(Dannenberg)。この2つはどちらも3.パフォーマンスとトレードオフの関係にあり、1.2.3.全てを同時に実現している言語は未だ存在しない(issue)。我々は（LLVMという高いパフォーマンスを発揮できるコンパイラ基盤を用いることで、）この3つを同時に実現できる音楽プログラミング言語mimiumとその実行環境を開発した。mimiumが3つが同時に達成できることにより、音楽をコードとして製作し、コードとして配布し、コードとしてを再生をするという動的な音楽配布の基盤（Infrastructure）として機能する可能性について議論する。

# 序論(Intro)

## なぜその領域か？

音楽プログラミング言語は1950年代から現在に至るまで活発に開発が進んでいる研究領域である。

音楽プログラミング言語はコンピューターを用いて音楽を用いる際に、汎用プログラミング言語の利用で求められる高度なハードウェアの操作ー例えばメモリ操作やマルチスレッド、時間の制御ーをプロフェッショナルなソフトウェアエンジニア以外にも効率的に扱えるようにするというメリットがある。

加えて、DAWなどの既存の音楽制作ソフトウェアを利用するだけでは不可能な新しい音楽の抽象化の手段を我々に与えてくれる。

---

# 背景(Background)

## 何がこの領域で問題になっている/重要なトピックか？

- 楽譜と信号処理を両方書けるようにすることは、microsoundをはじめ表現の幅を広げるのに有効な手段である（できないのは問題である）(Dannenbergの課題1/3)。

- - かつ、理想的には一つの言語でシンプルに書けると良い。
  - もうちょっと具体的にいうと、Semanticsの問題(そもそも言語がUGen書けるようにできてない)と、
  - Runtimeの問題(UGen書けるけど遅いとか、イベント制御のIndeterminacyとか)
  - Syntaxの問題もある（書けるし早いけど型情報多くて煩雑:Extempore）



- ブラックボックス(Dannenbergの課題2/3)

- - ブラックボックスがあると、言語としてのflexibility(expressiveness)が減る、制約が増える
  - プリミティブが多いので実装が煩雑、実行バイナリのサイズが大きくなる
  - ⇄プリミティブをたくさん用意する必要はないので、コンパイラ、ランタイムの実装がシンプルになり、コンパクト

- - ⇄その分、言語上で構築するライブラリの分量は増える（Faustのように）



基本的にこの2つは**パフォーマンスとのトレードオフ**になる、パフォーマンスもなんだかんだ重要

- リアルタイム実行は音楽言語において重要な要素の一つである
  - 一つは演奏、リアルタイムインタラクション(reference?いっぱいあるけども)
  - もう一つはラピッド・プロトタイピング（DSLとしての本分,Mcpherson)

1. 楽譜信号処理の両立vsパフォーマンス
   - Chronic(時間型で解決したけど遅い)
   - ExtemporeとかMaxMSP、スパコar/kr、型を分ける/言語を2種類にする
   - (バッファ間にイベントループを処理するPdやスパコのモデルではイベント処理のIndeterminacyも問題)

2. ブラックボックスvsパフォーマンス

- - ブラックボックスを減らし、小さいプリミティブでできるだけ多くを表現しようと思うとインタプリタではスピードに限界

  - - 信号処理はそもそもスピードが求められるので大変

  - ChucKでホワイトボックスジェネレータでさえパフォーマンスは落ちる

3つのうち2つまでを同時に実現はできている(ちょっと上と被るので整理したい)

- 楽譜信号処理両方&&ブラックボックス少ない、パフォーマンス悪い

- - Chronic
  - ChucK+ChuGen

- 楽譜と信号処理両立しており、パフォーマンスも良いが、ブラックボックスは残る

- - ChucK
  - Max、Pd、スパコ

- パフォーマンスとブラックボックスの少なさをとって楽譜信号処理の両立を諦める

- - 信号処理に限定したFaust,Kronos,Soul,UGG
  - ブラックボックスはないが信号処理だけ型制約の強い言語を使うExtempore
  - Max+Gen(さらに言語の種類が増える）

**3つ全てを同時に実現しているものは未だない（issue）**



——————

# 手法(Method)

## どうやって実現するか？How?

個別に技術課題としては解決されているので、いいとこ取りをする

LLVMとかコンパイラ技術の発達のおかげでリアルタイムにネイティブコードを吐けるようになった

基本的には、ExtemporeのJITコンパイラとランタイムを参考に、パフォーマンスとブラックボックスの少なさをとる

加えてFaustのセマンティクスを参考に、一つの言語上で信号処理を簡潔に扱えるようにする

---

今回はあまり対象にしないもの What is less prioritized 

リアルタイムインタラクション、ライブプログラミング（後々実現可能ではあるけども）

---

## 実装解説 Implementation

楽譜処理＆信号処理の両立

- 楽譜
- 信号処理



——

# 議論 Discussion

## これらが全て同時に実現できるとどうなるか？What will it be applied if all the problems are resolved?



楽譜も信号処理も書ける&&コンパイラとランタイムがコンパクト&&リアルタイム実行可能



⇄ 音楽をソースコードとして製作し、ソースコードのまま配布し、ソースコードを実行することで再生する



従来の音楽プログラミング言語のアプリケーションである、自作の楽器を作って演奏だったり、アルゴリズム作曲だったり、音楽を作る人のための応用を超えて、

- ソースコードのまま音楽を配布すればサイズも小さい(信号処理など共通するライブラリ部分はキャッシュして使いまわせる)
- ソースコードのまま音楽を再生できれば無限ループ、ジェネラティブ、ランダマイズなど、動的に変化する楽曲を実際にその場で実行できる
- (音楽アーカイブの面から見ても有効である)



といったメリットが考えられる。

## 課題 To be improved

- 楽譜と信号処理の両立を一つの言語で

- - 一つの言語仕様に載ってはいるものの、楽譜と信号処理でデザインパターンがまるで違うが（selfとtemporal recursion）
  - 現実的には楽譜レベルの表現を行うにはまだ配列や構造体が実装されていないので大変
  - Vector処理、特にFFTはSemanticsレベルで何か対策しないとできないかも

- ブラックボックス

- - オーディオファイル取り扱いとか、これからMIDIとかを扱おうとすると、IO周りのブラックボックス性はどのみち残る

  - 全てがPCMで収まるのであれば問題はないが、音楽はPCMだけではない

  - バイナリサイズが小さくなると言ったが、実際はChucK5MBに対して22MBある（LLVMのJIT部分が20MBぐらい食ってる、似た構造のExtemporeとほぼ同じ）

  - - オプティマイザとかをうまく切り分ければ減らせるのかも(その分実行速度は落ちるかも)

- パフォーマンス

- - 動的にインスタンスを作って殺す（パーティクルとか）みたいな処理は今はできず、そのうちできるようになったとしてもメモリ管理の抽象化をextemporeのように複雑化せずに実現できるかどうか

- 

# Conclusion