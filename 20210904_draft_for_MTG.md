# 研究概要

本研究は、音楽プログラミング言語mimiumの設計とその実装を述べ、プログラミング言語のソースコードを音楽を配布するための媒体として用いることの美学的価値について論ずるものである。



mimiumの1つの特徴を挙げるのであれば、mimiumという言語が直接的にこれまで不可能だった表現を可能にするというわけではない、言い換えると、新しい表現の開拓のための言語ではないというところだ。

例えば歴史上SuperColliderという言語は、グラフィカルに信号のデータフローを表現するのでは不可能な、動的なデータフローの書き換えや、データフロー自体のパラメトリックな増減をテキストという形式を再活用することで可能にしたし、ChucKという言語はそれまで、数十～数百サンプル単位での分解能しか持っていなかった時間方向に離散的なイベント処理を、サンプル単位で決定的（deterministic）に制御可能にすることによって、それまで汎用言語を使って記述するしかなかったグラニュラー合成のような処理を音楽向けのDSLの中でも容易に記述できるようにした。こうした例は言語の開発によって直接的に新しい表現を生んだ例、と言ってよいだろう。

しかしmimiumの主眼はそうした新しい表現の開拓ではない。そして、これはmimiumの他の言語と違う唯一特徴というわけでもない。新しい表現の開拓以外に主眼を置いた言語は他にもある。

例えばFaustのような言語は、DSPアルゴリズムを関数型の形式で記述し、C言語などの汎用言語のソースコードへと変換し、性能面の最適化やハードウェア管理はFaustのコンパイラが担うこような形をとる。こうすることで、ユーザーはメモリ管理のような音声処理と関係のない部分に時間を割く必要を無くし、アルゴリズムそのものの探究に集中させることができる（関心の分離）。また、1つのFaustのコードを、VSTプラグインやMaxで使用できるオブジェクト、Webアプリのモジュールなど複数の環境で使用することができるので、各環境のためにアルゴリズムを移植し直す必要がなくなる。（インフラストラクチャの役割）。

またライブコーディングやIDEも対象外である

また本研究のもう一つの大きな貢献は、そもそも音楽プログラミング言語とはそもそも何なのか、それを開発するとはどういうことなのか、それをなぜ開発するべきなのか、といった理論的枠組みの構築にある。

音楽プログラミング言語とはその名前的に、プログラミング言語を音楽に応用する一つのサブジャンルのように見えるが、歴史を辿れば汎用プログラミング言語が登場するのとほぼ同時にその歴史は始まっており、その実態はコンピューターを用いて新しい音楽表現を開拓する、コンピューター音楽の歴史と、プログラミング言語という、異なる機械同士で同じロジックを実行するため言葉のデザインという2つの歴史が相互に絡み合ったものとなっている。



## イントロ案2(置き場考え中)



なぜ、コンピューターはユニバーサルな、なんでも出来るはずの機械だと言われているのに、そして自分は新しい音楽を作りたいと思っているにもかかわらず、4万円もする作曲ソフトウェアを立ち上げてプロジェクトを作って少しいじってはああどうして今回もうまく作れないのだろうと思って閉じることを繰り返しているのだろうか。

これに対する一般的な回答はこうだろう。あなたに才能がないのではないか？才能という曖昧な言葉を使わないようにするのであれば、あなたがその作曲ソフトウェアを使いこなしていないのでは？あなたの作曲に対する知識が足りないのでは？などになろう。

- しかし本論文では敢えてこの疑問をひっくり返してみる。
  - 実は、本当は、そのソフトウェアの設計がよくないのではないか？
  - 実は、コンピューターを使って音楽を作るための環境や、それを形作る社会的状況がよくないのではないか？
  - 実は、私が作ろうとしている（そして、潜在的に受け入れられたがっている）音楽文化そのものがよくないのではないのか？
- この研究はある種の当事者研究ではないか
  - なぜなら、本当にコンピューターがユニバーサルで、みんなのためのマシンなら今頃私は自分が作りたいと思える音楽をもっと好き勝手に作っているはずではないのか。
  - 少なくとも不満を感じている人間がここに1人いるというのは重要なことではないのだろうか





# ”音楽プログラミング言語”とは

音楽プログラミング言語は、その言葉通りに受け取ると、汎用プログラミング言語を音楽のために応用したDomain Specific Languageと考えられるが、それは現存する音楽のための言語の一側面に過ぎない。

なぜなら、音楽プログラミング言語の祖先にあたるシステムであるMUSIC 1が開発されたのは1957年。最も古い汎用プログラミング言語のFORTRANが開発されたのも1956年とほぼ同時期だからである。

そもそも、70年代以降にかけての可変的メディア装置としてのコンピュータの概念が出来上がるまでは、コンピューターに対する入力インターフェース自体がテキストをベースにしたものであることが普通で、それゆえ音楽や音信号をコンピューターを用いて作るためのソフトウェアの入力インターフェースも必然的にテキストベースの物でしかなかった。



70年代以降に、ディスプレイ上に表示されたグラフィックを、マウスなどの装置でリアルタイムに操作できるグラフィカル・ユーザーインターフェース（GUI）環境が整うにつれて、音楽プログラミング環境も、Max(Puckette)を代表としてテキストインターフェースだけでなく、入出力を持つボックスをマウスで繋いでいくような形式など、テキストに留まらない形式でのプログラミング行為を可能にした。これは同時に、出力された信号などもオシロスコープのようなグラフィックとしてフィードバックが返ってきたり、パッチ（Maxにおけるプログラムのこと）中にスライダーのような、プログラムされたソフトウェアを操作するためのインターフェースが同居していたりといった、それまで存在していた”プログラムを構築するステップ”と”構築されたプログラムを使用するステップ”に明確な境目が無くなっていく歴史でもある。



また、コンピューターアーキテクチャのスタンダード（もっと言ってしまえば、x86アーキテクチャ）が定まるまでのプログラミングは、特定のハードウェアのための特定のプログラムを作るという側面が大きく、書かれたソフトウェアが様々なプラットフォームで使い回しが効くということでもなかったことも頭に入れておくべきだろう。

汎用プログラミング言語はそれまでの実在するハードウェアに対する命令列を可読性のあるテキストデータから出力するためのソフトウェアという側面だけでなく、ラムダ計算（引用）のような、計算過程自体を数学的になるべく普遍的になるように記述する代数学の理論との接続を見せるようになり、LISPやML、Haskellに代表されるような関数型プログラミング言語のパラダイムが発生してきた。

そしてこうした分野で培われたプログラミング言語の理論は現在ではFaustやKronosを代表とする、関数型でかつ音楽や音声処理のための言語の理論的基盤としても用いられるようになっている。



つまり、2020年代現在において、音楽プログラミング言語とは、コンピューターを用いて音楽を生成するためのソフトウェア群に始まりつつも、並行して発展してきた汎用プログラミング言語やその理論を取り込みつつ発展してきたソフトウェアやツールのことを指す。

なので、Maxのように前者の流れを強く汲むものは、Dannenbergが言うように、言語体系とランタイムやライブラリ、開発/実行環境があらかじめ切り離せない形式となっていることが多い。

逆に、汎用プログラミング言語の理論をベースに構築された言語、例えばExtemporeやFaust、Kronosでは、言語仕様は言語仕様として独立しておりランタイムが存在しないーあるいは複数のランタイムの実装があり得る、そのほか、決まったIDEが存在しなかったり、複数の開発/実行環境が存在するといった構成になっているものがある。



なお、用語として”音楽プログラミング環境(Music Programming Environment)”と”音楽プログラミング言語(Music Programming Language)”という2つの言葉は特に明示的な使い分けをされずに使用されることも多い（英語では、Computer Music LanguageやComputer Music Environment、Computer Music Systemsなどなど）が、本稿では、"音楽プログラミング環境”といった時には開発環境やライブラリなど、その言語を用いる時に利用するツール全体に重点を置きたいときに、”音楽プログラミング言語”といった場合にはその言語仕様や文法など、ソフトウェアというよりも言語そのものに着目したいときに、用いることを附しておく。

## 歴史

### 50年代以前

1928 ナイキスト　サンプリング理論予想

1949 シャノン　サンプリング理論証明

サイバネティクス

### 50年代 - OS以前

MUSIC 1,2,3

特定のコンピューターの上で動くシステム

### 70年 

Dynabook MetaMedia、Personal Dynamic Mediaとしてのコンピューターの誕生

GUI(非テキストインターフェース)、入出力の多様化

### 80年代 

パーソナルコンピュータの誕生（Apple、Commodore）

"To learn something about this, we must first realize that computers deal only in symbols." - Programming your own computer, Alan Key

- -> つまり、「パーソナルコンピューター」の概念にはフレキシブルなプログラミングの必要性がセットとなって想定されていたということ!!

MIDIの誕生

パーソナルコンピュータではチップチューンの時代、MML

一方で、研究所では専用DSPボードでのリアルタイム合成の時代（IRCAM 4XとMax/FTS）

### 90年代

WindowsとMacOSのスタンダード化、音源チップなしでのPCMリアルタイム合成

汎用言語からの理論の輸入

Opcode Max、Pure Data、SuperCollider

### 2000年代

iPhoneの登場、イーノのジェネラティブ音楽

ChucK

Faust 

Impromptu - Extempore

Chronic

### 2010年代

物理音楽メディア(CD)の消滅、ストリーミング:ユビキタス・コンピューティング



# 音楽プログラミング言語のtaxonomy

## 実装方法から見たときの分類-DSLのデザインパターン

一般的にプログラミング言語は、テキストの文字列データを解析して構文木と呼ばれるデータ構造に変換し、それを直接評価することで実行したり（インタプリタ型）、より低次の中間構造、例えばvirtual machineへの命令列やC言語のような汎用言語のソースコードなどへの段階的な変換を経て実行される場合がある。

音楽のためのプログラミング言語もこうした実装に則っているが、構文解析の部分はホスト言語(その言語自体を開発するための言語)の機能を利用しており、ライブラリのような形で実装されるものもある。構文解析から行うものをExternal DSL,ライブラリのような形で実装するものをInternal DSLと呼ぶこともある（Nishino2015）。

External,Internalといった実装のアプローチの違いをSpinellis2000はデザインパターンとして提示した。そのうちの一部を取り上げる。

- 文字列解析(一番自由度は高いが大変)
- 言語拡張（ホスト言語のライブラリとして実装）
- 言語特殊化（ホスト言語の一部の機能だけを使う）
- Source to Souce Transformation
- Pipeline

言語拡張、言語特殊化の表現の範囲は、言語を実装するためのホスト言語の自由度（演算子のオーバーロードができるか、高機能なマクロが使えるかなど）にも左右される。

例えばSuperColliderの文法をCoffeeScript（Javascriptに変換され実行する言語）で模したWebブラウザ上で動作する音声処理ライブラリ/DSLであるCoffeeColliderは文字列解析などは自分では行っておらず、特定のオブジェクトに対する+演算子や*演算子の挙動をオーバーロードしたりすることで、CoffeeScriptの文法で可能な範囲の表現でSyntaxを模している。

```coff
(->
  noise = PinkNoise.ar(0.2)
  noise = Mix Array.fill 10, (i)->
    Resonz.ar(noise, i * 800 + 200, 0.05)
  noise = (noise * 0.2 + noise * Decay.kr(Dust.kr(0.5), 10))
  noise = RHPF.ar(noise, LFNoise0.kr(0.5).range(220, 880), rq:0.001)
  CombL.ar(noise, delaytime:0.5, decaytime:25).dup() * 0.5
).play()
```

またTidalCyclesのように文字列解析、言語拡張、言語特殊化を組み合わせて実装されることもある。

```has
d1 $ sound "bd*4" # gain (every 3 (rev) $ "1 0.8 0.5 0.7")
```

- $や#はホスト言語であるHaskellにおける中置演算子(**言語拡張**)
- soundやgain、everyなどはHaskell上でライブラリとして定義された関数
- “”で囲まれた部分はHaskell上ではただの文字列
- ParsecというHaskellの**字句解析**ライブラリで内部的にパースしている
- ユーザーはHaskellの関数定義や型宣言など高度な文法を知る必要はない（**言語特殊化**）
- TidalCyclesはSuperColliderに対してOSCを送り音を出す(**パイプライン**)

一般的には中間表現を低次へ変換していくほどより抽象的な操作に近づいていくので言語処理系の実装が汎用言語の実装に近くなっていく。

またMaxやPure Dataのようなビジュアル言語の場合は、保存されているテキスト/バイナリデータを解釈してビジュアルインターフェースとして表示する評価と、音声処理のためのデータ構造としての評価と2方向の評価が行われていると解釈することができる。この時の保存されているデータ形式は例えばMaxではJSONというJavascriptのための汎用データ表現形式を用いているように、その言語のSemanticsとは関係のない汎用的なデータ構造を利用している場合もある。

### DSLの中でも、音楽特有の問題 - なぜライブラリとしてのDSLではダメなのか？

HaskellみたいなDSL作りやすい言語で全てライブラリとして実装しちゃダメなのか？→基本的には厳しい

OSのプリエンプティブスケジューリング（ユーザプログラムが時間に関与できない）

​	例外- Xenomaiの様なカーネル拡張

信号処理中にヒープメモリ確保をできない問題

​	

## 音楽言語を評価するterminology - General,Efficient and Expressive

今後音楽言語を新しく設計するにあたってどんな課題に取り組むべきか？

そもそも評価するための語彙が整理されていないのが問題では

- General

- Efficient

- Expressive

トレードオフがあると言っている文献がいくつかある

Dannenbergは音楽のためのプログラミング言語を特徴付ける要素としてSyntax、Semantics、Runtime、Libraries、IDE(Interface?)、Community&Resourcesという6要素を挙げた。(以下、それぞれ説明する)

- Syntax

- Semantics
- Runtime
- Libraries
- IDE(Interface?)
- Community&Resources

一方で、こうした言語ごとの実装や設計における要素が、言語にどのような特性をもたらすのかについての整理はこれまで行われていない。

汎用のプログラミング言語においてはCoblenz and et al.(2018)で、

- General
- Efficient "Execution cost"
- Expressive "To what extent can users specify their intent using the formal mechanisms of the language?"
- Modifiability "How easy or hard is it to adapt software to changing requirements?"
- Learnability
- Understandability
- Portability
- ...



といったobejectivesを提案しており、音楽プログラミング言語においてもこのような言語設定における目標を整理することで、より言語設計を明確に行うことができ、またその目標が達成されたかどうかの評価を客観的に行うことができるようになると考えられる。

特に、Coblenzらのobjectivesの中でも挙げられているGeneral、Efficient、Expressiveという3つの語は音楽プログラミング言語の設計の観点の中でもよく使われる用語でありながら、実際には指している意味が複数混在しているので用語を整理する必要がある。

例えば、Brandt2002は音楽言語設計における大きな問題としてExpressivenessとGeneralityのTradeoffが存在するとして、それらを両立するOCamlフレームワークChronicを開発している。

![image-20210606155655532](/Users/tomoya/Documents/papers/cmmr-2021/chronic-tradeoff.png)

ここでのExpressivenessとは“ユーザーが読みやすく書きやすい”、 Generalとは“可能な表現の範囲が広い”という意味で用いられている。またChronicはOCamlというホスト言語の実行速度の問題もあって、リアルタイムで実行はできなかった。つまりChronicではgeneralとexpressiveの両立はできたが実行時パフォーマンスという新たなトレードオフが発生していたことがわかる。

またLazzarini2013ではCSoundの設計において、Score、Orchestra、Instrumentという3種類の内部言語を用いるアプローチにおいて、

> 音楽プログラミングにおいて多言語アプローチを取ると、ユーザは**汎用性(Generality)**と**効率性(Efficiency)**のバランスを取りやすくなる、

と述べている。ここでの用語は、続く以下の説明を参照すると

> タスクに応じてプログラマは異なる複雑度のエントリーポイントを選択することが可能になる。より低く汎用的なレベルではより複雑なコードの設計が必要だが幅広い結果を得られる。一方、より高い、特殊化、具体化されたレベルではプログラミングに必要な労力という観点からプロセスはより効率的になるだろう。

ここでのEfficiencyはCoblenzらの論文におけるEfficiencyとは異なり、ユーザーが目的のプログラムを構築するまでの効率のことを指している。これはむしろCoblenzのLernabilityやMcphersonらの分析におけるRapid-Prototypingのしやすさに相当するものだと言える。



Dannernberg2018

> This article considers models of computation that are especially important for music programming, how these models are supported in programming languages, and how this leads to **expressive** and **efficient** programs. 

ここでのEfficientはprogramsに掛かっているのでRuntime Costのことを指していると推察できる。

このように、同じEfficiencyというワードでもComputerが負担するコストとユーザーが負担するコストという異なる事項を指している場合があることがわかる。そこで、次の項では音楽プログラミング言語を評価、また設計の指針となるためのvalueを、ユーザーがソースを編集し、実行し、そのフィードバックが帰ってくるhuman-in-the-loopシステムとしてモデル化し、その際に考えられるコストや自由度をユーザー、コンピューターそれぞれの観点で分類することで提案する。



### 音楽プログラミングの行為のモデル化

#### ![Screen Shot 2021-06-07 at 15.12.26](/Users/tomoya/Documents/papers/cmmr-2021/src/diagram1.png)

![Screen Shot 2021-06-07 at 16.25.25](/Users/tomoya/Documents/papers/cmmr-2021/src/diagram2.png)

​	ユーザーへのフィードバックが音を出す前にわかる場合と、音を鳴らして初めてわかるものとある（型チェックとか）

### User-Side

学習しやすさ

表現可能な空間の広さ(Generality)がMcpherson2020におけるOpen-Endedness、BrandtにおけるGeneralityにあたるものと言える。

ユーザーが必要とするコーディングコスト、すなわちユーザーが想定している表現にどれだけ簡単に辿り着けるような言語仕様になっているかどうかがExpressivenessにあたるものと言える。

### Computer-Side

Compilation cost

#### コンピューターが必要とするコスト（Runtime Efficiency/Execution Cost）

#### 実行可能な空間の広さ（Portability）

### Edit-Executeの繰り返しやすさ

#### ユーザー側：Learnability

#### コンピューター側：Dynamic Modification

(Mcpherson2020におけるRapid-Prototyping、Mcpherson2020のDynamismは実行中に動的にUGenのデータフローを作り替えられるかどうかという話なので少し違う)　ここが極まるとLive Codingになる

### Development自体のしやすさ

C++とかで作られてると大変、インタプリタ型なら簡単

言語の自己反映性が高ければ言語自体のコーディングしやすさと一致してくる（機能拡張がライブラリを書くことで可能になる）

#### それぞれのトレードオフ

10個全部を満たすのは無理、少なくとも全部を撮ろうとするとDevelopmentが超大変

![Screen Shot 2021-09-04 at 1.02.02](/Users/tomoya/Library/Application Support/typora-user-images/Screen Shot 2021-09-04 at 1.02.02.png)

![Screen Shot 2021-09-04 at 1.02.47](/Users/tomoya/Library/Application Support/typora-user-images/Screen Shot 2021-09-04 at 1.02.47.png)

![Screen Shot 2021-09-04 at 1.03.09](/Users/tomoya/Library/Application Support/typora-user-images/Screen Shot 2021-09-04 at 1.03.09.png)

他、具体的には（ここを綺麗に整理できたら嬉しい）

- インタプリタ型の実装だとEdit-Executeの変更はしやすくなる、その代わり信号処理とかをスクラッチで実装するのは実行コストが嵩む
- 

## Classifying Langages



|               | Easy Coding | Compilation Cost | Possible Expression | Execution Cost | Portability |      | Learnability | Dynamic Modification |
| ------------- | ----------- | ---------------- | ------------------- | -------------- | ----------- | ---- | ------------ | -------------------- |
| SuperCollider |             |                  |                     |                |             |      |              |                      |
| Pure Data      |             |                  |                     |                |             |      |              |                      |
| Max           |             |                  |                     |                |             |      |              |                      |
| ChucK         |             |                  |                     |                |             |      |              |                      |
| LC            |             |                  |                     |                |             |      |              |                      |
| Gwion         |             |                  |                     |                |             |      |              |                      |
| CSound        |             |                  |                     |                |             |      |              |                      |
| CLM           |             |                  |                     |                |             |      |              |                      |
| Chronic       |             |                  |                     |                |             |      |              |                      |
| Faust         |             |                  |                     |                |             |      |              |                      |
| Soul          |             |                  |                     |                |             |      |              |                      |
| Vult          |             |                  |                     |                |             |      |              |                      |
| Kronos        |             |                  |                     |                |             |      |              |                      |
| Extempore     |             |                  |                     |                |             |      |              |                      |
| mimium        |             |                  |                     |                |             |      |              |                      |
| Alda          |             |                  |                     |                |             |      |              |                      |
| Takt          |             |                  |                     |                |             |      |              |                      |
| TidalCycles   |             |                  |                     |                |             |      |              |                      |
| FoxDot        |             |                  |                     |                |             |      |              |                      |
| IXI           |             |                  |                     |                |             |      |              |                      |
| Sonic Pi      |             |                  |                     |                |             |      |              |                      |
| Overtone      |             |                  |                     |                |             |      |              |                      |
| Nyquist       |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |
|               |             |                  |                     |                |             |      |              |                      |







# mimiumのデザイン方針

トレードオフがあることは前節で説明した。その上でどういう方針で作るか？

- Self-Extensibilityの重視。

- 汎用言語に最低限の音楽のための要素を追加する。

  - 簡易スケジューラ。@演算子
  - 信号処理のための時系列参照機能。
    - delayなどの組み込み関数
    - selfによるフィードバック表現。

- Portabilityも重要。

  - OSのスケジューラの存在を前提にしないこと(Extemporeとの違い)。

- Expression Domainとして、信号処理と、楽譜的なイベント処理を両方扱えるようにすること。

  - Faustなどの様に、信号処理だけでランタイムレスな設計ではなく、スケジューラがある

  

## 実装の方針

ゼロから文字列パースするコンパイラをC++で書く。Piggybackもなし

"NO threshold and NO ceiling"  Seymore Papert





