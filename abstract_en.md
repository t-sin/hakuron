This dissertation aims to develop a theoretical framework for the design of Programming Language for Music (PLfM) as an infrastructure through the implementation of mimium(minimal-musical-medium), 

Today, computers are so much around us that it is inevitable that we will pass through them in order to create and receive music, but programming, which allows us to manipulate computers with the highest degree of freedom as a means of creating music, is still not the primary means in the music creation environment. In Chapter 1, the direction of the dissertation , which is to conduct research to change such a contradictory situation through the practice of designing PLfM by oneself is presented.

As a background, Chapter 2 shows that intentional misuse of technology with amateurism, such as circuit bending and glitching [Cascone, 2009], which worked until the 2000s, no longer works in today's software-centric music technology culture. As a means of countering the increasing inaccessibility of a highly advanced technology, the author compares the different approaches to open up a hidden technology with a deep understanding, presenting as a performance [Tweiz,2009], drawing the audience into the perspective of the technologist [UCNV,2020], creating a different infrastructure from the ground [HandredRabbits,2018], and places the design of music programming languages as musical practices in the broadest sense.

Chapter 3 examines how Research through Design (Rtd), the way of academic contribution by creating artifacts through a methodology different from science, can be applied to the research area of programming languages. Referring a value of RtD in HCI[Gaver, 2012] and Claim-Evidence-Correspondence in evaluation of programming languages [Markstrum, 2010]. The evidence part can be evaluated objectively as in engineering research, and the overall research field is positioned as a research field where one can find a theory by differentiating individual research, not by generalizing. Also, referring to Magnusson's concept of Epistemic Tools [Magnusson, 2009], the author position programming language design as an act of designing the infrastructure of music technology over a long period of time, as an example of a situation in which RtD expands its field.

In Chapter 4, the author re-position the history of music programming languages based on the existing literature, as an entity sandwiched between the two major histories of music infrastructure and computer science outlined in the previous chapter. The author divides the history into three major parts: the 50s, the 70s, and the 90s and beyond, each corresponding to the topics of computer music research in the lab, the era of chiptunes, and the confluence of general-purpose programming languages with theory. In this history, I will show that today's music programming languages can be regarded as music software that dares to take advantage of the language format and its characteristics among the many interfaces that exist.

In Chapter 5, the author investigates the characteristics and the implementation methodologies of PLfM. To this end, the author proposes the process of using a music programming language as a Human-in-the-Loop model, referring to the study of evaluation vocabularies in general-purpose programming languages [Coblenz, 2018], and showing that there are trade-offs: a larger runtime black box is more resistant to dynamic changes, a smaller black box increases the generality of the expression itself, and trying to achieve both dynamic changes and generality increases the complexity of the design and the cost of implementation.

In Chapter 6, the details of mimium, PLfM designed by the author [Matsuura, Jo, 2021] is described. First, three design principles are proposed: 1) reduce the black box as much as possible, 2) do not aim to create new expressions, and 3) the need for a programming language as an infrastructure. mimium is a statically typed language with type inference, and it is implemented in the form of a general-purpose functional programming language design and implementation with a minimum of additional language specifications for music. One of its features is the $@$ operator for scheduling function execution, and the other is the notation of functions with states, which allows signal processing with internal states to be described in the same way as ordinary functions. In this paper, we will show that mimium can be implemented as a library (with no loss of performance), and compare it with existing languages.

In Chapter 7, based on the problems of the current implementation of mimium, the author analyze the production of mimium from the perspective of the trade-off choices that exist in the design of PLfM, the position of mimium in the history of PLfM, the design of mimium as RtD, and the implementation of the programming language as one of the musical practices. It is suggested that the policy of creating a language with fewer black boxes in music programming language production leads to two types of work: implementation of the host language and library construction on top of it. As a result, a contradiction was revealed: the implementation of the host language was divided into less work related to music.

In the final chapter, the ontology and history of music programming languages presented in the first half of the chapter and the implementation of mimium and the analysis of the implementation process presented in the second half of the chapter are further generalized. The research field of "Civil Engineering of Music" is examined, including a comparison with recent music information processing research and trends in computer architecture. As a future research topic, the author reviews the theories that relate to the fundamentals of computers, such as operating systems and computer architecture, which have become a background in the applied field of music, and show that they can provide clues to solving the problems that have become apparent with the implementation of mimium.
